<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>NEON QUAKE: ARENA</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #050505; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; user-select: none; }
        #ui-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; display: flex; flex-direction: column; justify-content: space-between; }
        #crosshair { position: absolute; top: 50%; left: 50%; width: 24px; height: 24px; transform: translate(-50%, -50%); pointer-events: none; mix-blend-mode: difference; }
        .hud-row { display: flex; justify-content: space-between; padding: 30px; font-size: 20px; font-weight: 800; letter-spacing: 2px; color: #fff; }
        #health-display { color: #ff0055; text-shadow: 0 0 15px #ff0055; }
        #score-display { color: #00ffaa; text-shadow: 0 0 15px #00ffaa; }
        #wave-display { color: #ffee00; text-shadow: 0 0 15px #ffee00; }
        
        #start-screen { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: radial-gradient(circle, rgba(20,0,40,0.9) 0%, rgba(0,0,0,1) 100%); display: flex; flex-direction: column; align-items: center; justify-content: center; color: white; z-index: 10; pointer-events: auto; cursor: pointer; transition: opacity 0.5s; }
        h1 { font-size: 80px; margin: 0; font-style: italic; text-transform: uppercase; background: linear-gradient(45deg, #00ffff, #ff00aa); -webkit-background-clip: text; -webkit-text-fill-color: transparent; filter: drop-shadow(0 0 20px rgba(0,255,255,0.5)); }
        p { font-size: 18px; color: #aaa; margin-top: 10px; }
        .hidden { opacity: 0; pointer-events: none; }
        #damage-overlay { position: absolute; top:0; left:0; width:100%; height:100%; pointer-events: none; transition: background 0.1s; mix-blend-mode: overlay; }
        #loading { position: absolute; bottom: 20px; color: #666; font-size: 12px; }
    </style>
</head>
<body>

    <div id="damage-overlay"></div>
    
    <div id="start-screen">
        <h1>Neon Quake</h1>
        <p>WASD to Move | SPACE to Jump | CLICK to Shoot</p>
        <div id="loading">Loading Assets...</div>
        <p style="margin-top:40px; color:#0ff; animation: blink 1s infinite;">[ CLICK TO ENGAGE ]</p>
    </div>

    <div id="ui-layer">
        <div class="hud-row">
            <div id="score-display">SCORE: 0</div>
            <div id="wave-display">WAVE: 1</div>
        </div>
        <svg id="crosshair" viewBox="0 0 100 100">
            <rect x="48" y="20" width="4" height="20" fill="#0ff"/>
            <rect x="48" y="60" width="4" height="20" fill="#0ff"/>
            <rect x="20" y="48" width="20" height="4" fill="#0ff"/>
            <rect x="60" y="48" width="20" height="4" fill="#0ff"/>
            <circle cx="50" cy="50" r="2" fill="#fff"/>
        </svg>
        <div class="hud-row">
            <div id="health-display">INTEGRITY: 100%</div>
            <div id="ammo-display">INF</div>
        </div>
    </div>

    <style> @keyframes blink { 50% { opacity: 0; } } </style>

    <!-- Libraries -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { PointerLockControls } from 'three/addons/controls/PointerLockControls.js';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';

        // --- CONFIGURATION ---
        const PHYSICS = {
            gravity: 30.0,
            moveSpeed: 60.0,
            friction: 6.0,
            jumpForce: 14.0,
            eyeHeight: 2.5
        };

        const COLORS = {
            ambient: 0x100020,
            sky: 0x050505,
            grid: 0xaa00ff,
            bullet: 0x00ffff,
            enemyHit: 0xffffff
        };

        let state = {
            score: 0,
            wave: 1,
            health: 100,
            enemiesAlive: 0,
            isPlaying: false,
            lastTime: performance.now()
        };

        // --- SETUP ---
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(COLORS.sky);
        scene.fog = new THREE.FogExp2(COLORS.sky, 0.012);

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 200);
        const renderer = new THREE.WebGLRenderer({ antialias: false, powerPreference: "high-performance" });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.toneMapping = THREE.ReinhardToneMapping;
        renderer.shadowMap.enabled = true;
        document.body.appendChild(renderer.domElement);

        // Post Processing
        const composer = new EffectComposer(renderer);
        composer.addPass(new RenderPass(scene, camera));
        const bloom = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
        bloom.threshold = 0.1;
        bloom.strength = 1.0;
        bloom.radius = 0.5;
        composer.addPass(bloom);

        // --- ASSET LOADING ---
        const loader = new GLTFLoader();
        let enemyModel = null;
        let mixer = null; // For animations
        const mixers = []; // Array to hold mixers for all enemies

        // Load a Robot Model from Three.js Examples
        loader.load('https://raw.githubusercontent.com/mrdoob/three.js/master/examples/models/gltf/RobotExpressive/RobotExpressive.glb', 
            (gltf) => {
                enemyModel = gltf.scene;
                // Scale and fix materials
                enemyModel.scale.set(0.5, 0.5, 0.5);
                enemyModel.traverse(c => {
                    if(c.isMesh) {
                        c.castShadow = true;
                        c.material.emissive = new THREE.Color(0xff0055);
                        c.material.emissiveIntensity = 0.2;
                    }
                });
                
                // Extract animation clip
                const animations = gltf.animations;
                if(animations && animations.length) {
                    enemyModel.userData.animations = animations;
                }

                document.getElementById('loading').innerText = "System Ready.";
            },
            undefined,
            (error) => {
                console.warn("Model failed to load (likely CORS if local). Using fallback.");
                document.getElementById('loading').innerText = "Model Load Failed - Using Fallback";
            }
        );

        // --- WORLD ---
        // Grid Floor
        const grid = new THREE.GridHelper(200, 50, 0xff00aa, 0x220044);
        grid.position.y = 0.05;
        scene.add(grid);

        const floor = new THREE.Mesh(
            new THREE.PlaneGeometry(200, 200),
            new THREE.MeshStandardMaterial({ color: 0x050510, roughness: 0.1, metalness: 0.8 })
        );
        floor.rotation.x = -Math.PI / 2;
        floor.receiveShadow = true;
        scene.add(floor);

        // Lighting
        const ambient = new THREE.AmbientLight(COLORS.ambient, 3.0);
        scene.add(ambient);
        
        const dirLight = new THREE.DirectionalLight(0xffffff, 2.0);
        dirLight.position.set(10, 20, 10);
        dirLight.castShadow = true;
        dirLight.shadow.camera.top = 50;
        dirLight.shadow.camera.bottom = -50;
        dirLight.shadow.camera.left = -50;
        dirLight.shadow.camera.right = 50;
        scene.add(dirLight);

        // Pillars
        const obstacles = [];
        const boxGeo = new THREE.BoxGeometry(1, 1, 1);
        const boxMat = new THREE.MeshStandardMaterial({ color: 0x00aaaa, roughness: 0.1, metalness: 0.9 });

        for(let i=0; i<40; i++) {
            if(Math.random() > 0.8) continue;
            const h = 4 + Math.random() * 10;
            const w = 2 + Math.random() * 6;
            const m = new THREE.Mesh(boxGeo, boxMat);
            
            const x = (Math.random() - 0.5) * 120;
            const z = (Math.random() - 0.5) * 120;
            if(Math.sqrt(x*x + z*z) < 15) continue; // Clear spawn

            m.position.set(x, h/2, z);
            m.scale.set(w, h, w);
            m.castShadow = true;
            m.receiveShadow = true;
            scene.add(m);
            
            obstacles.push(new THREE.Box3().setFromObject(m));
        }

        // --- PLAYER WEAPON (Procedural Gun) ---
        const gunGroup = new THREE.Group();
        camera.add(gunGroup);
        
        // Gun Body
        const gunGeo = new THREE.BoxGeometry(0.2, 0.2, 0.6);
        const gunMat = new THREE.MeshStandardMaterial({ color: 0x222222, roughness: 0.4 });
        const gunMesh = new THREE.Mesh(gunGeo, gunMat);
        gunMesh.position.set(0.25, -0.25, -0.5);
        gunGroup.add(gunMesh);

        // Barrel
        const barrelGeo = new THREE.CylinderGeometry(0.05, 0.05, 0.6, 8);
        const barrelMat = new THREE.MeshStandardMaterial({ color: 0x555555, metalness: 1.0 });
        const barrel = new THREE.Mesh(barrelGeo, barrelMat);
        barrel.rotation.x = Math.PI / 2;
        barrel.position.set(0.25, -0.2, -0.7);
        gunGroup.add(barrel);

        // Energy Core (Glowing)
        const coreGeo = new THREE.BoxGeometry(0.06, 0.06, 0.3);
        const coreMat = new THREE.MeshBasicMaterial({ color: 0x00ffff });
        const core = new THREE.Mesh(coreGeo, coreMat);
        core.position.set(0.25, -0.25, -0.55);
        gunGroup.add(core);

        // Muzzle Light
        const muzzleLight = new THREE.PointLight(0x00ffff, 0, 10);
        muzzleLight.position.set(0.25, -0.2, -1.0);
        gunGroup.add(muzzleLight);

        scene.add(camera); // Important: Add camera to scene so gun renders

        // --- PLAYER CONTROLLER ---
        const controls = new PointerLockControls(camera, document.body);
        const velocity = new THREE.Vector3();
        const direction = new THREE.Vector3();
        const input = { f: 0, b: 0, l: 0, r: 0, jump: false };

        const onKeyDown = (e) => {
            switch (e.code) {
                case 'ArrowUp': case 'KeyW': input.f = 1; break;
                case 'ArrowLeft': case 'KeyA': input.l = 1; break;
                case 'ArrowDown': case 'KeyS': input.b = 1; break;
                case 'ArrowRight': case 'KeyD': input.r = 1; break;
                case 'Space': if(!input.jump) velocity.y = PHYSICS.jumpForce; input.jump = true; break;
            }
        };
        const onKeyUp = (e) => {
            switch (e.code) {
                case 'ArrowUp': case 'KeyW': input.f = 0; break;
                case 'ArrowLeft': case 'KeyA': input.l = 0; break;
                case 'ArrowDown': case 'KeyS': input.b = 0; break;
                case 'ArrowRight': case 'KeyD': input.r = 0; break;
                case 'Space': input.jump = false; break;
            }
        };
        document.addEventListener('keydown', onKeyDown);
        document.addEventListener('keyup', onKeyUp);
        
        document.addEventListener('click', () => {
            if(state.isPlaying) shoot();
            else {
                controls.lock();
                state.isPlaying = true;
                document.getElementById('start-screen').classList.add('hidden');
            }
        });

        // --- GAME OBJECTS ---
        const projectiles = [];
        const enemies = [];
        const particles = [];

        function shoot() {
            // Visuals
            muzzleLight.intensity = 5;
            setTimeout(() => muzzleLight.intensity = 0, 50);
            
            // Recoil animation (Visual only)
            gunGroup.position.z += 0.1;

            // Logic
            const sphere = new THREE.Mesh(
                new THREE.SphereGeometry(0.15), 
                new THREE.MeshBasicMaterial({ color: COLORS.bullet })
            );
            sphere.position.copy(camera.position);
            
            // Offset to match gun barrel
            const right = new THREE.Vector3(1, 0, 0).applyQuaternion(camera.quaternion);
            const down = new THREE.Vector3(0, -1, 0).applyQuaternion(camera.quaternion);
            sphere.position.addScaledVector(right, 0.25);
            sphere.position.addScaledVector(down, 0.2);
            
            const dir = new THREE.Vector3();
            camera.getWorldDirection(dir);
            // Add slight offset to start projectile ahead
            sphere.position.addScaledVector(dir, 1.0);

            scene.add(sphere);
            projectiles.push({ mesh: sphere, vel: dir.multiplyScalar(80), life: 2.0 });
        }

        function spawnEnemy() {
            let mesh;
            let mixer = null;

            if (enemyModel) {
                mesh = enemyModel.clone();
                // Setup Animation
                if (enemyModel.userData.animations) {
                    mixer = new THREE.AnimationMixer(mesh);
                    // Play the "Running" or "Walking" clip. usually 0 or 1 in this model
                    const clip = enemyModel.userData.animations.find(c => c.name === 'Run') || enemyModel.userData.animations[0];
                    if(clip) mixer.clipAction(clip).play();
                    mixers.push(mixer);
                }
            } else {
                // Fallback Geometry
                const geo = new THREE.ConeGeometry(1, 2, 4);
                const mat = new THREE.MeshStandardMaterial({ color: 0xff0055, roughnes: 0.2 });
                mesh = new THREE.Mesh(geo, mat);
            }

            // Position
            const angle = Math.random() * Math.PI * 2;
            const dist = 40 + Math.random() * 40;
            mesh.position.set(
                camera.position.x + Math.cos(angle) * dist,
                0,
                camera.position.z + Math.sin(angle) * dist
            );
            
            scene.add(mesh);
            enemies.push({ mesh: mesh, hp: 3, speed: 12 + Math.random() * 5, mixer: mixer });
        }

        function createExplosion(pos, color) {
            for(let i=0; i<8; i++) {
                const m = new THREE.Mesh(
                    new THREE.BoxGeometry(0.4,0.4,0.4), 
                    new THREE.MeshBasicMaterial({ color: color })
                );
                m.position.copy(pos);
                const v = new THREE.Vector3((Math.random()-0.5)*10, (Math.random()-0.5)*10, (Math.random()-0.5)*10);
                scene.add(m);
                particles.push({ mesh: m, vel: v, life: 0.8 });
            }
        }

        // --- UPDATE LOOP ---
        function update(dt) {
            if (!controls.isLocked) return;

            // 1. Physics Movement
            // FIX: In Three.js, Forward is -Z. 
            // If we press W (input.f), we want negative Z direction relative to camera.
            // If we press S (input.b), we want positive Z.
            // So Z direction = input.b - input.f (1 - 0 = 1 = Backwards)
            
            let moveX = input.r - input.l;
            let moveZ = input.b - input.f; 

            let moveDir = new THREE.Vector3(moveX, 0, moveZ).normalize();
            
            // Align input to camera look direction (Y-axis rotation only)
            const euler = new THREE.Euler(0, camera.rotation.y, 0, 'YXZ');
            moveDir.applyEuler(euler);

            if (camera.position.y <= PHYSICS.eyeHeight) {
                // Ground
                velocity.x -= velocity.x * PHYSICS.friction * dt;
                velocity.z -= velocity.z * PHYSICS.friction * dt;
                velocity.addScaledVector(moveDir, PHYSICS.moveSpeed * dt);
                velocity.y = Math.max(0, velocity.y);
                camera.position.y = PHYSICS.eyeHeight;
            } else {
                // Air
                velocity.y -= PHYSICS.gravity * dt;
                velocity.addScaledVector(moveDir, (PHYSICS.moveSpeed * 0.2) * dt);
            }

            const delta = velocity.clone().multiplyScalar(dt);
            const prevPos = camera.position.clone();
            camera.position.add(delta);

            // Collision (Walls)
            const pBox = new THREE.Box3().setFromCenterAndSize(camera.position, new THREE.Vector3(1, 2, 1));
            for(let b of obstacles) {
                if(pBox.intersectsBox(b)) {
                    camera.position.x = prevPos.x;
                    camera.position.z = prevPos.z;
                    break;
                }
            }
            if(camera.position.y < PHYSICS.eyeHeight) camera.position.y = PHYSICS.eyeHeight;

            // 2. Weapon Sway
            const swayAmount = 0.05;
            const targetX = -moveX * swayAmount + 0.25; // base pos
            const targetY = -Math.abs(Math.sin(performance.now() * 0.01) * (moveX || moveZ ? 0.02 : 0.005)) - 0.25;
            
            // Smoothly lerp weapon
            gunGroup.position.x += (targetX - gunGroup.position.x) * 10 * dt;
            gunGroup.position.y += (targetY - gunGroup.position.y) * 10 * dt;
            gunGroup.position.z += (-0.5 - gunGroup.position.z) * 10 * dt; // Return from recoil

            // 3. Projectiles
            for(let i=projectiles.length-1; i>=0; i--) {
                const p = projectiles[i];
                p.life -= dt;
                p.mesh.position.addScaledVector(p.vel, dt);
                
                // Hit Check
                let hit = false;
                for(let j=enemies.length-1; j>=0; j--) {
                    const e = enemies[j];
                    // Simple distance check for hit
                    if(p.mesh.position.distanceTo(e.mesh.position) < 1.5) {
                        createExplosion(e.mesh.position, 0xff00aa);
                        e.hp--;
                        if(e.hp <= 0) {
                            scene.remove(e.mesh);
                            enemies.splice(j, 1);
                            state.score += 50;
                            state.enemiesAlive--;
                            
                            // Remove mixer
                            const mixIdx = mixers.indexOf(e.mixer);
                            if(mixIdx > -1) mixers.splice(mixIdx, 1);
                        } else {
                            // Knockback
                            const kb = p.vel.clone().normalize().multiplyScalar(2);
                            e.mesh.position.add(kb);
                        }
                        hit = true;
                        break;
                    }
                }

                if(hit || p.life <= 0 || p.mesh.position.y < 0) {
                    scene.remove(p.mesh);
                    projectiles.splice(i, 1);
                }
            }

            // 4. Enemies
            // Update animations
            mixers.forEach(m => m.update(dt));

            for(let e of enemies) {
                e.mesh.lookAt(camera.position.x, 0, camera.position.z);
                const dir = new THREE.Vector3().subVectors(camera.position, e.mesh.position).normalize();
                dir.y = 0;
                
                // Collision with player
                if(e.mesh.position.distanceTo(camera.position) < 1.5) {
                    state.health -= 1;
                    document.getElementById('damage-overlay').style.background = "rgba(255,0,0,0.3)";
                    setTimeout(()=>document.getElementById('damage-overlay').style.background = "transparent", 100);
                    if(state.health <= 0) gameOver();
                } else {
                    e.mesh.position.addScaledVector(dir, e.speed * dt);
                }
            }

            // 5. Wave Management
            if(state.enemiesAlive <= 0) {
                state.wave++;
                state.health = Math.min(100, state.health + 25);
                const count = 3 + state.wave * 2;
                for(let i=0; i<count; i++) spawnEnemy();
                state.enemiesAlive = count;
            }

            // 6. Particles
            for(let i=particles.length-1; i>=0; i--) {
                const p = particles[i];
                p.life -= dt;
                p.mesh.position.addScaledVector(p.vel, dt);
                p.mesh.scale.multiplyScalar(0.9);
                if(p.life <= 0) {
                    scene.remove(p.mesh);
                    particles.splice(i, 1);
                }
            }

            // HUD
            document.getElementById('score-display').innerText = `SCORE: ${state.score}`;
            document.getElementById('wave-display').innerText = `WAVE: ${state.wave}`;
            document.getElementById('health-display').innerText = `INTEGRITY: ${Math.floor(state.health)}%`;
        }

        function gameOver() {
            state.isPlaying = false;
            controls.unlock();
            document.getElementById('start-screen').classList.remove('hidden');
            document.querySelector('h1').innerText = "SYSTEM FAILURE";
            document.querySelector('#loading').innerText = `FINAL SCORE: ${state.score}`;
            
            // Reset
            state.health = 100;
            state.score = 0;
            state.wave = 1;
            state.enemiesAlive = 0;
            enemies.forEach(e => scene.remove(e.mesh));
            enemies.length = 0;
            projectiles.forEach(p => scene.remove(p.mesh));
            projectiles.length = 0;
            mixers.length = 0;
            camera.position.set(0, 5, 0);
        }

        // Main Loop
        function animate() {
            requestAnimationFrame(animate);
            const now = performance.now();
            const dt = Math.min((now - state.lastTime) / 1000, 0.1);
            state.lastTime = now;

            if(state.isPlaying) update(dt);
            
            composer.render();
        }

        // Handle Resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
        });

        animate();

    </script>
</body>
</html>