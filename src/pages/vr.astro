<head>
  <meta
    name="viewport"
    content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0"
  />

  <script src="/a-frame/aframe-master.min.js" is:inline></script>

  <script>
    if (!window.isSecureContext) {
      alert("WebXR needs HTTPS");
    }
  </script>

  <!-- Import the client script as a module -->
  <script>
    import { initializeChat } from "../scripts/chat.js";

    // Add this before the window.addEventListener('load') code
    AFRAME.registerComponent("animation-logger", {
      init: function () {
        this.el.addEventListener("model-loaded", (e) => {
          const model = this.el.getObject3D("mesh");
          const animations = model.animations;
          console.log("Available animations:", animations);
          animations.forEach((clip, index) => {
            console.log(`Animation ${index}: ${clip.name}`);
          });
        });
      },
    });

    // Add this component to manage animations
    AFRAME.registerComponent("robot-animation-controller", {
      init: function () {
        this.el.addEventListener("model-loaded", () => {
          console.log("Model loaded, setting initial animation to Idle");
          /*
          this.el.setAttribute('animation-mixer', {
            clip: 'Idle',
            loop: 'repeat',
            timeScale: 10  // Speed up animation 10x
          });
          */
        });

        // Listen for pause toggle events
        window.addEventListener("togglePause", (event) => {
          const isPaused = event.detail.isPaused;
          /*
          this.el.setAttribute('animation-mixer', {
            clip: isPaused ? 'Idle' : 'Standing',
            loop: 'repeat',
            timeScale: 10  // Speed up animation 10x
          });
          */
        });
      },
    });

    const LoopMode = {
      once: THREE.LoopOnce,
      repeat: THREE.LoopRepeat,
      pingpong: THREE.LoopPingPong,
    };

    /**
     * animation-mixer
     *
     * Player for animation clips. Intended to be compatible with any model format that supports
     * skeletal or morph animations through THREE.AnimationMixer.
     * See: https://threejs.org/docs/?q=animation#Reference/Animation/AnimationMixer
     */
    AFRAME.registerComponent("animation-mixer", {
      schema: {
        clip: { default: "*" },
        useRegExp: { default: false },
        duration: { default: 0 },
        clampWhenFinished: { default: false, type: "boolean" },
        crossFadeDuration: { default: 0 },
        loop: { default: "repeat", oneOf: Object.keys(LoopMode) },
        repetitions: { default: Infinity, min: 0 },
        timeScale: { default: 1 },
        startAt: { default: 0 },
      },

      init: function () {
        /** @type {THREE.Mesh} */
        this.model = null;
        /** @type {THREE.AnimationMixer} */
        this.mixer = null;
        /** @type {Array<THREE.AnimationAction>} */
        this.activeActions = [];

        const model = this.el.getObject3D("mesh");

        if (model) {
          this.load(model);
        } else {
          this.el.addEventListener("model-loaded", (e) => {
            this.load(e.detail.model);
          });
        }
      },

      load: function (model) {
        const el = this.el;
        this.model = model;
        this.mixer = new THREE.AnimationMixer(model);
        this.mixer.addEventListener("loop", (e) => {
          el.emit("animation-loop", {
            action: e.action,
            loopDelta: e.loopDelta,
          });
        });
        this.mixer.addEventListener("finished", (e) => {
          el.emit("animation-finished", {
            action: e.action,
            direction: e.direction,
          });
        });
        if (this.data.clip) this.update({});
      },

      remove: function () {
        if (this.mixer) this.mixer.stopAllAction();
      },

      update: function (prevData) {
        if (!prevData) return;

        const data = this.data;
        const changes = AFRAME.utils.diff(data, prevData);

        // If selected clips have changed, restart animation.
        if ("clip" in changes) {
          this.stopAction();
          if (data.clip) this.playAction();
          return;
        }

        // Otherwise, modify running actions.
        this.activeActions.forEach((action) => {
          if ("duration" in changes && data.duration) {
            action.setDuration(data.duration);
          }
          if ("clampWhenFinished" in changes) {
            action.clampWhenFinished = data.clampWhenFinished;
          }
          if ("loop" in changes || "repetitions" in changes) {
            action.setLoop(LoopMode[data.loop], data.repetitions);
          }
          if ("timeScale" in changes) {
            action.setEffectiveTimeScale(data.timeScale);
          }
        });
      },

      stopAction: function () {
        const data = this.data;
        for (let i = 0; i < this.activeActions.length; i++) {
          data.crossFadeDuration
            ? this.activeActions[i].fadeOut(data.crossFadeDuration)
            : this.activeActions[i].stop();
        }
        this.activeActions.length = 0;
      },

      playAction: function () {
        if (!this.mixer) return;

        const model = this.model,
          data = this.data,
          clips = model.animations || (model.geometry || {}).animations || [];

        if (!clips.length) return;

        const re = data.useRegExp ? data.clip : wildcardToRegExp(data.clip);

        for (let clip, i = 0; (clip = clips[i]); i++) {
          if (clip.name.match(re)) {
            const action = this.mixer.clipAction(clip, model);

            action.enabled = true;
            action.clampWhenFinished = data.clampWhenFinished;
            if (data.duration) action.setDuration(data.duration);
            if (data.timeScale !== 1)
              action.setEffectiveTimeScale(data.timeScale);
            // animation-mixer.startAt and AnimationAction.startAt have very different meanings.
            // animation-mixer.startAt indicates which frame in the animation to start at, in msecs.
            // AnimationAction.startAt indicates when to start the animation (from the 1st frame),
            // measured in global mixer time, in seconds.
            action.startAt(this.mixer.time - data.startAt / 1000);
            action
              .setLoop(LoopMode[data.loop], data.repetitions)
              .fadeIn(data.crossFadeDuration)
              .play();
            this.activeActions.push(action);
          }
        }
      },

      tick: function (t, dt) {
        if (this.mixer && !isNaN(dt)) this.mixer.update(dt / 1000);
      },
    });

    /**
     * Creates a RegExp from the given string, converting asterisks to .* expressions,
     * and escaping all other characters.
     */
    function wildcardToRegExp(s) {
      return new RegExp(
        "^" + s.split(/\*+/).map(regExpEscape).join(".*") + "$",
      );
    }

    /**
     * RegExp-escapes all characters in the given string.
     */
    function regExpEscape(s) {
      return s.replace(/[|\\{}()[\]^$+*?.]/g, "\\$&");
    }

    // Initialize chat when the page loads
    window.addEventListener("load", async () => {
      console.log("Page loaded, initializing chat...");

      try {
        const client = await initializeChat();
        console.log("Chat initialized");

        // Get reference to elements
        const robotText = document.querySelector("a-text");
        const pauseButton = document.querySelector("#pauseButton");
        console.log("Robot text element:", robotText);

        // Handle pause button clicks
        pauseButton.addEventListener("click", () => {
          const isPaused = pauseButton.getAttribute("data-paused") === "true";
          pauseButton.setAttribute("data-paused", !isPaused);
          pauseButton.textContent = isPaused ? "PAUSE" : "RESUME";

          // Dispatch pause state change event
          window.dispatchEvent(
            new CustomEvent("togglePause", {
              detail: { isPaused: !isPaused },
            }),
          );

          // Update robot text
          robotText.setAttribute("value", isPaused ? "LISTENING" : "PAUSED");
        });

        // Listen for assistant responses
        window.addEventListener("assistantResponse", (event) => {
          console.log("Received assistant response:", event.detail.text);
          robotText.setAttribute("value", event.detail.text);
        });
      } catch (error) {
        console.error("Error initializing chat:", error);
      }
    });
  </script>
</head>

<style>
  .pause-button {
    position: absolute;
    top: 20px;
    left: 20px;
    z-index: 1000;
    padding: 10px 20px;
    background-color: #4cc3d9;
    border: none;
    border-radius: 5px;
    color: black;
    font-weight: bold;
    cursor: pointer;
    box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
  }

  .pause-button:hover {
    background-color: #3aa3b9;
  }
</style>

<!-- Add the HTML button before the a-scene -->
<button id="pauseButton" class="pause-button" data-paused="true">PAUSE</button>

<div>
  <a-scene>
    <!-- Add assets management system -->
    <a-assets>
      <a-asset-item id="robot" src="/a-frame/robot.gltf"></a-asset-item>
    </a-assets>

    <a-sky color="#87CEEB"></a-sky>
    <a-plane
      position="0 0 0"
      rotation="-90 0 0"
      width="30"
      height="30"
      color="#8B4513"
      shadow="receive: true"></a-plane>

    <!-- Robot with floating text above it -->
    <a-entity position="0 0 -3" scale="0.5 0.5 0.5">
      <!-- Robot model -->
      <a-entity
        gltf-model="#robot"
        scale="0.5 0.5 0.5"
        animation-mixer="clip: '*'"
        robot-animation-controller
        animation-logger
        shadow="cast: true"></a-entity>

      <a-entity position="0 2.5 0">
        <a-text
          value="Initializing..."
          scale="2 2 2"
          color="#000000"
          align="center"
          side="double"
          billboard></a-text>
      </a-entity>
    </a-entity>

    <a-entity position="0 0 0">
      <a-camera id="camera"></a-camera>
    </a-entity>

    <a-entity
      id="rightHand"
      hand-tracking-grab-controls="hand: right"
      coffee-spawner="targetElementSelector: [data-world-mesh=table]"
    ></a-entity>
    <a-entity
      id="leftHand"
      hand-tracking-grab-controls="hand: left"
      coffee-spawner="targetElementSelector: [data-world-mesh=table]"
    ></a-entity>
  </a-scene>
</div>
