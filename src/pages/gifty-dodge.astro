---
import Layout from "../layouts/Layout.astro";
---

<Layout title="Gifty Dodge - Help the gift reach its recipient!" hideHeader={true}>
  <div id="game-container"></div>
  <div id="custom-popup" class="hidden">
    <div class="popup-content">
      <h2>Congratulations!</h2>
      <p id="popup-message"></p>
      <button id="popup-button">Next Level</button>
    </div>
  </div>
</Layout>

<style>
  body, html {
    margin: 0;
    padding: 0;
    overflow: hidden;
    width: 100%;
    height: 100%;
    touch-action: none;
    user-select: none;
    -webkit-user-select: none;
    -moz-user-select: none;
    -ms-user-select: none;
    -webkit-touch-callout: none;
  }
  
  #game-container {
    width: 100%;
    height: 100vh;
    display: block;
    position: absolute;
    top: 0;
    left: 0;
    user-select: none;
    -webkit-user-select: none;
    -moz-user-select: none;
    -ms-user-select: none;
    -webkit-touch-callout: none;
  }

  #custom-popup {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background-color: rgba(0, 0, 0, 0.7);
    display: flex;
    justify-content: center;
    align-items: center;
    z-index: 1000;
  }

  .popup-content {
    background-color: #ffe0f0;
    border: 4px solid #ff69b4;
    border-radius: 15px;
    padding: 20px;
    text-align: center;
    max-width: 80%;
    box-shadow: 0 0 20px rgba(255, 105, 180, 0.6);
  }

  .popup-content h2 {
    color: #ff69b4;
    margin-top: 0;
    font-size: 28px;
  }

  .popup-content p {
    color: #333;
    margin-bottom: 20px;
    font-size: 18px;
  }

  #popup-button {
    background-color: #ff69b4;
    color: white;
    border: none;
    padding: 10px 20px;
    border-radius: 5px;
    font-size: 16px;
    cursor: pointer;
    transition: background-color 0.3s;
  }

  #popup-button:hover {
    background-color: #ff4da6;
  }

  .hidden {
    display: none !important;
  }
</style>

<script>
  import * as THREE from 'three';

  // Prevent zoom and text selection on mobile
  document.addEventListener('touchstart', (e) => {
    if (e.touches.length > 1) {
      e.preventDefault();
    }
  }, { passive: false });
  
  document.addEventListener('touchmove', (e) => {
    e.preventDefault();
  }, { passive: false });

  // Game variables
  let scene, camera, renderer;
  let giftBox, grassField;
  let gameHeight = 15; // Number of jumps to win
  let currentPosition = 0;
  let gameWidth = 10; // Arbitrary width units
  let isJumping = false;
  let level = 1;
  let obstacles = [];
  let clocksToRotate = [];
  let truckSpeedChangeTimers = [];
  let debugMode = true; // Enable debug visualization
  let hitboxHelpers = []; // Store hitbox visualizers
  
  // Sound effects
  let jumpStartSound, jumpLandSound, collisionSound, winSound, bgMusic;
  let soundsLoaded = false;
  let musicMuted = false;
  let fxMuted = false;
  
  // Audio control buttons (Three.js objects)
  let musicButton, fxButton;
  let raycaster, mouse;
  
  // State machine
  const GameState = {
    IDLE: 'idle',
    CHARGING: 'charging',
    JUMPING: 'jumping',
    GAME_OVER: 'gameOver',
    LEVEL_COMPLETE: 'levelComplete'
  };
  
  let currentState = GameState.IDLE;
  let chargeStartTime = 0;
  let maxChargeTime = 1000; // 1 second max charge
  let chargeStrength = 0;
  let chargeIndicator;

  // Initialize the game
  function init() {
    // Create scene
    scene = new THREE.Scene();
    scene.background = new THREE.Color(0xffe0f0); // Light pink background

    // Create camera (orthographic for top-down view)
    const aspect = window.innerWidth / window.innerHeight;
    const viewSize = 15;
    camera = new THREE.OrthographicCamera(
      -viewSize * aspect / 2, 
      viewSize * aspect / 2, 
      viewSize / 2, 
      -viewSize / 2, 
      0.1, 
      1000
    );
    camera.position.set(0, 0, 10);
    camera.lookAt(0, 0, 0);

    // Create renderer
    renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.getElementById('game-container').appendChild(renderer.domElement);

    // Create grassy field
    const fieldGeometry = new THREE.PlaneGeometry(gameWidth, gameHeight);
    const fieldMaterial = new THREE.MeshBasicMaterial({ color: 0x66cc66 }); // Green color
    grassField = new THREE.Mesh(fieldGeometry, fieldMaterial);
    grassField.position.set(0, 0, -1);
    scene.add(grassField);

    // Load sounds
    loadSounds();

    // Create gift box character
    createGiftBox();
    
    // Create goal (hands)
    createGoal();
    
    // Add some initial obstacles
    createObstacles();

    // Create charge indicator
    createChargeIndicator();
    
    // Create Three.js audio control buttons
    createAudioButtons();
    
    // Setup raycaster for button interaction
    raycaster = new THREE.Raycaster();
    mouse = new THREE.Vector2();
    
    // Handle window resize
    window.addEventListener('resize', onWindowResize);
    
    // Add touch/click event listener
    window.addEventListener('click', handleClick);
    window.addEventListener('mousedown', handleMouseDown);
    window.addEventListener('mouseup', handleMouseUp);
    window.addEventListener('mousemove', handleMouseMove);
    window.addEventListener('keydown', handleKeyDown);
    window.addEventListener('keyup', handleKeyUp);
    window.addEventListener('touchstart', function(e) {
      e.preventDefault();
      handleTouchStart(e);
    });
    window.addEventListener('touchend', function(e) {
      e.preventDefault();
      handleTouchEnd(e);
    });
    window.addEventListener('touchmove', function(e) {
      e.preventDefault();
      handleTouchMove(e);
    });

    // Setup popup button
    document.getElementById('popup-button').addEventListener('click', function() {
      document.getElementById('custom-popup').classList.add('hidden');
      createObstacles(); // New obstacle pattern
    });

    // Start the animation loop
    animate();
  }
  
  // Create Three.js audio control buttons
  function createAudioButtons() {
    // Music button
    const musicGeometry = new THREE.CircleGeometry(0.4, 16);
    const musicMaterial = new THREE.MeshBasicMaterial({ 
      color: 0xf2f60d, // Yellow
      transparent: true,
      opacity: 0.8
    });
    musicButton = new THREE.Mesh(musicGeometry, musicMaterial);
    
    // Position in top-right corner of screen
    const aspect = window.innerWidth / window.innerHeight;
    const viewSize = 15;
    musicButton.position.set(viewSize * aspect / 2 - 0.5, viewSize / 2 - 1, 1);
    scene.add(musicButton);
    
    // Music icon (note symbol)
    const noteGeometry = new THREE.PlaneGeometry(0.8, 0.8);
    const noteTexture = new THREE.CanvasTexture(createTextureCanvas('ðŸŽµ'));
    const noteMaterial = new THREE.MeshBasicMaterial({ 
      map: noteTexture,
      transparent: true
    });
    const noteIcon = new THREE.Mesh(noteGeometry, noteMaterial);
    noteIcon.position.set(0, 0, 0.01);
    musicButton.add(noteIcon);
    
    // Add a highlight effect for better visual feedback
    const musicHighlightGeometry = new THREE.RingGeometry(0.8, 0.9, 32);
    const musicHighlightMaterial = new THREE.MeshBasicMaterial({
      color: 0xffffff,
      transparent: true,
      opacity: 0.5,
      side: THREE.DoubleSide
    });
    const musicHighlight = new THREE.Mesh(musicHighlightGeometry, musicHighlightMaterial);
    musicHighlight.position.set(0, 0, 0.005);
    musicHighlight.visible = false;
    musicButton.add(musicHighlight);
    
    // Store reference to icon for updating
    musicButton.userData = {
      icon: noteIcon,
      highlight: musicHighlight,
      type: 'music',
      muted: musicMuted,
      isHovered: false
    };
    
    // Update appearance if muted
    if (musicMuted) {
      musicButton.material.color.set(0x969696); // Gray
      noteIcon.material.map = new THREE.CanvasTexture(createTextureCanvas('ðŸ”‡'));
      noteIcon.material.needsUpdate = true;
    }
    
    // Sound effects button
    const fxGeometry = new THREE.CircleGeometry(0.4, 32);
    const fxMaterial = new THREE.MeshBasicMaterial({ 
      color: 0xf2f60d, // Yellow
      transparent: true,
      opacity: 0.8
    });
    fxButton = new THREE.Mesh(fxGeometry, fxMaterial);
    
    // Position next to music button
    fxButton.position.set(viewSize * aspect / 2 - 1.5, viewSize / 2 - 1, 1);
    scene.add(fxButton);
    
    // Sound icon
    const soundGeometry = new THREE.PlaneGeometry(0.8, 0.8);
    const soundTexture = new THREE.CanvasTexture(createTextureCanvas('ðŸ”Š'));
    const soundMaterial = new THREE.MeshBasicMaterial({ 
      map: soundTexture,
      transparent: true
    });
    const soundIcon = new THREE.Mesh(soundGeometry, soundMaterial);
    soundIcon.position.set(0, 0, 0.01);
    fxButton.add(soundIcon);
    
    // Add a highlight effect for better visual feedback
    const fxHighlightGeometry = new THREE.RingGeometry(0.8, 0.9, 32);
    const fxHighlightMaterial = new THREE.MeshBasicMaterial({
      color: 0xffffff,
      transparent: true,
      opacity: 0.5,
      side: THREE.DoubleSide
    });
    const fxHighlight = new THREE.Mesh(fxHighlightGeometry, fxHighlightMaterial);
    fxHighlight.position.set(0, 0, 0.005);
    fxHighlight.visible = false;
    fxButton.add(fxHighlight);
    
    // Store reference to icon for updating
    fxButton.userData = {
      icon: soundIcon,
      highlight: fxHighlight,
      type: 'fx',
      muted: fxMuted,
      isHovered: false
    };
    
    // Update appearance if muted
    if (fxMuted) {
      fxButton.material.color.set(0x969696); // Gray
      soundIcon.material.map = new THREE.CanvasTexture(createTextureCanvas('ðŸ”‡'));
      soundIcon.material.needsUpdate = true;
    }
    
    // Add a dedicated click handler for the buttons
    window.addEventListener('click', (e) => {
      checkButtonClick(e.clientX, e.clientY);
    });
  }
  
  // Create a canvas texture with emoji
  function createTextureCanvas(emoji) {
    const canvas = document.createElement('canvas');
    canvas.width = 128;
    canvas.height = 128;
    const ctx = canvas.getContext('2d');
    
    // Clear canvas
    ctx.fillStyle = 'rgba(0, 0, 0, 0)';
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    
    // Draw emoji
    ctx.fillStyle = 'white';
    ctx.font = '80px Arial';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText(emoji, canvas.width / 2, canvas.height / 2);
    
    return canvas;
  }
  
  // Handle button clicks
  function checkButtonClick(x, y) {
    console.log("Checking button click at:", x, y);
    
    // Convert screen coordinates to normalized device coordinates
    mouse.x = (x / window.innerWidth) * 2 - 1;
    mouse.y = -(y / window.innerHeight) * 2 + 1;
    
    console.log("Normalized coordinates:", mouse.x, mouse.y);
    
    // Update the picking ray with the camera and mouse position
    raycaster.setFromCamera(mouse, camera);
    
    // Calculate objects intersecting the picking ray
    const intersects = raycaster.intersectObjects([musicButton, fxButton], true);
    
    console.log("Intersections found:", intersects.length);
    
    if (intersects.length > 0) {
      const button = intersects[0].object;
      console.log("Intersected object:", button);
      
      // Check if we hit a button or its child
      const targetButton = button.userData && button.userData.type ? button : button.parent;
      console.log("Target button:", targetButton);
      
      if (targetButton && targetButton.userData && targetButton.userData.type === 'music') {
        console.log("Music button clicked");
        // Visual feedback - scale animation
        animateButtonPress(musicButton);
        toggleMusic();
        return true;
      } else if (targetButton && targetButton.userData && targetButton.userData.type === 'fx') {
        console.log("FX button clicked");
        // Visual feedback - scale animation
        animateButtonPress(fxButton);
        toggleFx();
        return true;
      }
    }
    
    return false;
  }
  
  // Check for button hover
  function checkButtonHover(x, y) {
    // Convert screen coordinates to normalized device coordinates
    mouse.x = (x / window.innerWidth) * 2 - 1;
    mouse.y = -(y / window.innerHeight) * 2 + 1;
    
    // Update the picking ray with the camera and mouse position
    raycaster.setFromCamera(mouse, camera);
    
    // Calculate objects intersecting the picking ray
    const intersects = raycaster.intersectObjects([musicButton, fxButton], true);
    
    // Reset hover states
    if (musicButton.userData.isHovered) {
      musicButton.userData.isHovered = false;
      musicButton.userData.highlight.visible = false;
    }
    
    if (fxButton.userData.isHovered) {
      fxButton.userData.isHovered = false;
      fxButton.userData.highlight.visible = false;
    }
    
    // Set hover state for intersected button
    if (intersects.length > 0) {
      const button = intersects[0].object;
      const targetButton = button.userData.type ? button : button.parent;
      
      targetButton.userData.isHovered = true;
      targetButton.userData.highlight.visible = true;
    }
  }
  
  // Animate button press
  function animateButtonPress(button) {
    // Save original scale
    const originalScale = button.scale.clone();
    
    // Scale down
    button.scale.set(0.9, 0.9, 0.9);
    
    // Scale back up after a short delay
    setTimeout(() => {
      button.scale.copy(originalScale);
    }, 100);
  }
  
  // Toggle music
  function toggleMusic() {
    musicMuted = !musicMuted;
    console.log("Music toggle activated, new state:", musicMuted);
    
    if (musicMuted) {
      // Update button appearance
      musicButton.material.color.set(0x969696); // Gray
      const muteTexture = new THREE.CanvasTexture(createTextureCanvas('ðŸ”‡'));
      musicButton.userData.icon.material.map = muteTexture;
      musicButton.userData.icon.material.needsUpdate = true;
      
      // Pause background music
      bgMusic.pause();
      console.log("Music paused");
    } else {
      // Update button appearance
      musicButton.material.color.set(0xf2f60d); // Yellow
      const musicTexture = new THREE.CanvasTexture(createTextureCanvas('ðŸŽµ'));
      musicButton.userData.icon.material.map = musicTexture;
      musicButton.userData.icon.material.needsUpdate = true;
      
      // Play background music
      bgMusic.play().catch(e => console.log("Audio play failed:", e));
      console.log("Music playing");
    }
    
    musicButton.userData.muted = musicMuted;
  }
  
  // Toggle sound effects
  function toggleFx() {
    fxMuted = !fxMuted;
    console.log("FX toggle activated, new state:", fxMuted);
    
    if (fxMuted) {
      // Update button appearance
      fxButton.material.color.set(0x969696); // Gray
      const muteTexture = new THREE.CanvasTexture(createTextureCanvas('ðŸ”‡'));
      fxButton.userData.icon.material.map = muteTexture;
      fxButton.userData.icon.material.needsUpdate = true;
      
      // Mute sound effects
      jumpStartSound.volume = 0;
      jumpLandSound.volume = 0;
      collisionSound.volume = 0;
      winSound.volume = 0;
      console.log("FX muted");
    } else {
      // Update button appearance
      fxButton.material.color.set(0xf2f60d); // Yellow
      const fxTexture = new THREE.CanvasTexture(createTextureCanvas('ðŸ”Š'));
      fxButton.userData.icon.material.map = fxTexture;
      fxButton.userData.icon.material.needsUpdate = true;
      
      // Unmute sound effects
      jumpStartSound.volume = 1;
      jumpLandSound.volume = 1;
      collisionSound.volume = 1;
      winSound.volume = 1;
      console.log("FX unmuted");
    }
    
    fxButton.userData.muted = fxMuted;
  }

  // Handle mouse down event
  function handleMouseDown(e) {
    // Check if we clicked a button
    if (checkButtonClick(e.clientX, e.clientY)) {
      e.preventDefault();
      e.stopPropagation();
      return; // Button was clicked, don't process game action
    }
    
    if (currentState === GameState.IDLE) {
      startCharging();
    }
  }

  // Handle mouse up event
  function handleMouseUp(e) {
    if (currentState === GameState.CHARGING) {
      releaseJump();
    }
  }

  // Handle mouse move event for button hover
  function handleMouseMove(e) {
    checkButtonHover(e.clientX, e.clientY);
  }

  // Handle click event (for compatibility)
  function handleClick(e) {
    // Check if we clicked a button
    if (checkButtonClick(e.clientX, e.clientY)) {
      e.preventDefault();
      e.stopPropagation();
      return; // Button was clicked, don't process game action
    }
    
    // Only use this for devices that don't support mousedown/mouseup
    if (!('ontouchstart' in window) && !('onmousedown' in window)) {
      if (currentState === GameState.IDLE) {
        startCharging();
        // Simulate immediate release
        setTimeout(releaseJump, 100);
      }
    }
  }

  // Handle key down event
  function handleKeyDown(e) {
    if (currentState === GameState.IDLE) {
      startCharging();
    }
  }

  // Handle key up event
  function handleKeyUp(e) {
    if (currentState === GameState.CHARGING) {
      releaseJump();
    }
  }

  // Handle touch start event
  function handleTouchStart(e) {
    // Check if we touched a button
    if (e.touches.length > 0 && checkButtonClick(e.touches[0].clientX, e.touches[0].clientY)) {
      e.preventDefault();
      e.stopPropagation();
      return; // Button was touched, don't process game action
    }
    
    if (currentState === GameState.IDLE) {
      startCharging();
    }
  }

  // Handle touch end event
  function handleTouchEnd(e) {
    if (currentState === GameState.CHARGING) {
      releaseJump();
    }
  }

  // Handle touch move event for button hover
  function handleTouchMove(e) {
    if (e.touches.length > 0) {
      checkButtonHover(e.touches[0].clientX, e.touches[0].clientY);
    }
  }

  // Start charging the jump
  function startCharging() {
    currentState = GameState.CHARGING;
    chargeStartTime = Date.now();
    chargeStrength = 0;
    
    // Play jump start sound
    if (soundsLoaded && !fxMuted) {
      jumpStartSound.currentTime = 0;
      jumpStartSound.play().catch(e => console.log("Audio play failed:", e));
    }
    
    // Start charge animation
    animateCharging();
  }

  // Animate the charging state
  function animateCharging() {
    if (currentState === GameState.CHARGING) {
      const currentTime = Date.now();
      const elapsedTime = currentTime - chargeStartTime;
      
      // Calculate charge strength (0 to 1)
      chargeStrength = Math.min(elapsedTime / maxChargeTime, 1);
      
      // Update charge indicator
      chargeIndicator.scale.set(1, chargeStrength, 1);
      
      // Continue animation
      requestAnimationFrame(animateCharging);
    }
  }

  // Release the jump
  function releaseJump() {
    if (currentState === GameState.CHARGING) {
      currentState = GameState.JUMPING;
      
      // Reset charge indicator
      chargeIndicator.scale.set(1, 0, 1);
      
      // Play jump release sound
      if (soundsLoaded && !fxMuted) {
        jumpLandSound.currentTime = 0;
        jumpLandSound.play().catch(e => console.log("Audio play failed:", e));
      }
      
      // Execute jump with charge strength
      playerJump(chargeStrength);
    }
  }

  // Player jump function
  function playerJump(strength = 1) {
    if (currentState === GameState.JUMPING) {
      // Calculate jump distance based on strength with no minimum (pixel precision)
      const jumpDistance = strength * 1.5;
      const targetY = giftBox.position.y + jumpDistance;
      
      // Animation
      const jumpAnimation = () => {
        const jumpSpeed = 0.1 * (1 + strength); // Faster jump for stronger charge
        if (giftBox.position.y < targetY) {
          giftBox.position.y += jumpSpeed;
          requestAnimationFrame(jumpAnimation);
        } else {
          giftBox.position.y = Math.min(targetY, gameHeight/2 - 0.5); // Cap at top of screen
          currentState = GameState.IDLE;
          
          // Check if player reached the top
          if (giftBox.position.y >= gameHeight/2 - 1) {
            levelComplete();
          }
          
          // Check collision with obstacles
          checkCollisions();
        }
      };
      
      requestAnimationFrame(jumpAnimation);
    }
  }

  // Check for collisions with obstacles
  function checkCollisions() {
    // Create a box3 for the gift box at its current position
    const giftBoxHitbox = giftBox.userData.hitbox.clone();
    giftBoxHitbox.translate(giftBox.position);
    
    for (const obstacle of obstacles) {
      // Get the obstacle's hitbox at its current position
      const obstacleHitbox = obstacle.userData.hitbox.clone();
      obstacleHitbox.translate(obstacle.position);
      
      // Check for intersection
      if (giftBoxHitbox.intersectsBox(obstacleHitbox)) {
        // Collision detected - reset the game
        if (soundsLoaded && !fxMuted) {
          collisionSound.currentTime = 0;
          collisionSound.play().catch(e => console.log("Audio play failed:", e));
        }
        currentState = GameState.GAME_OVER;
        resetGame();
        break;
      }
    }
  }

  // Reset the game when player collides with obstacle
  function resetGame() {
    giftBox.position.set(0, -gameHeight/2 + 0.5, 0);
    currentState = GameState.IDLE;
  }

  // Complete the level
  function levelComplete() {
    level++;
    currentState = GameState.LEVEL_COMPLETE;
    
    // Play win sound
    if (soundsLoaded && !fxMuted) {
      winSound.currentTime = 0;
      winSound.play().catch(e => console.log("Audio play failed:", e));
    }
    
    // Show custom popup
    document.getElementById('popup-message').textContent = `You completed level ${level-1}!`;
    document.getElementById('custom-popup').classList.remove('hidden');
    
    resetGame();
  }

  // Handle window resize
  function onWindowResize() {
    const aspect = window.innerWidth / window.innerHeight;
    const viewSize = 15;
    
    camera.left = -viewSize * aspect / 2;
    camera.right = viewSize * aspect / 2;
    camera.top = viewSize / 2;
    camera.bottom = -viewSize / 2;
    
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
  }

  // Animation loop
  function animate() {
    requestAnimationFrame(animate);
    
    // Move obstacles
    obstacles.forEach(obstacle => {
      obstacle.position.x += obstacle.userData.speed;
      
      // Wrap around screen edges
      if (obstacle.position.x > gameWidth/2 + 1) {
        obstacle.position.x = -gameWidth/2 - 1;
      } else if (obstacle.position.x < -gameWidth/2 - 1) {
        obstacle.position.x = gameWidth/2 + 1;
      }
      
      // Update hitbox helper position
      updateHitboxHelper(obstacle);
      
      // Check for collisions during movement
      if (currentState !== GameState.GAME_OVER && currentState !== GameState.LEVEL_COMPLETE) {
        const giftBoxHitbox = giftBox.userData.hitbox.clone();
        giftBoxHitbox.translate(giftBox.position);
        
        const obstacleHitbox = obstacle.userData.hitbox.clone();
        obstacleHitbox.translate(obstacle.position);
        
        if (giftBoxHitbox.intersectsBox(obstacleHitbox)) {
          // Collision detected during movement
          if (soundsLoaded && !fxMuted) {
            collisionSound.currentTime = 0;
            collisionSound.play().catch(e => console.log("Audio play failed:", e));
          }
          currentState = GameState.GAME_OVER;
          resetGame();
        }
      }
    });
    
    // Rotate clock hands
    clocksToRotate.forEach(clock => {
      if (clock.userData.hourHand && clock.userData.minuteHand) {
        clock.userData.hourHand.rotation.z += clock.userData.rotationSpeed.hour;
        clock.userData.minuteHand.rotation.z += clock.userData.rotationSpeed.minute;
      }
    });
    
    // Update charge indicator position to follow gift box horizontally
    if (chargeIndicator) {
      chargeIndicator.position.x = giftBox.position.x + 0.6;
      chargeIndicator.position.y = giftBox.position.y;
    }
    
    // Update gift box hitbox helper
    updateHitboxHelper(giftBox);
    
    renderer.render(scene, camera);
  }

  // Create a visual helper for hitboxes
  function createHitboxHelper(object) {
    if (!object.userData.hitbox) return;
    
    const box = object.userData.hitbox.clone();
    const size = box.getSize(new THREE.Vector3());
    
    const geometry = new THREE.BoxGeometry(size.x, size.y, size.z);
    const material = new THREE.MeshBasicMaterial({ 
      color: 0xff0000, 
      wireframe: true,
      transparent: true,
      opacity: 0.5
    });
    
    const helper = new THREE.Mesh(geometry, material);
    helper.visible = debugMode;
    
    // Store reference to the object this helper belongs to
    helper.userData.targetObject = object;
    
    // Position helper at the center of the hitbox
    const center = box.getCenter(new THREE.Vector3());
    helper.position.copy(center);
    
    scene.add(helper);
    hitboxHelpers.push(helper);
    
    return helper;
  }
  
  // Update hitbox helper position
  function updateHitboxHelper(object) {
    const helper = hitboxHelpers.find(h => h.userData.targetObject === object);
    if (!helper) return;
    
    const hitbox = object.userData.hitbox.clone();
    hitbox.translate(object.position);
    
    const center = hitbox.getCenter(new THREE.Vector3());
    helper.position.copy(center);
  }
  
  // Toggle debug visuals
  function updateDebugVisuals() {
    hitboxHelpers.forEach(helper => {
      helper.visible = debugMode;
    });
  }

  // Load sound effects
  function loadSounds() {
    // Create audio elements
    jumpStartSound = new Audio('/gifty-dodge/jump-press.mp3');
    jumpLandSound = new Audio('/gifty-dodge/jump-release.mp3');
    collisionSound = new Audio('/gifty-dodge/ow.mp3');
    winSound = new Audio('/gifty-dodge/yay.mp3');
    bgMusic = new Audio('/gifty-dodge/boba-date.mp3');
    
    // Set background music properties
    bgMusic.loop = true;
    bgMusic.volume = 0.25;
    
    // Handle sound loading
    const soundsToLoad = [jumpStartSound, jumpLandSound, collisionSound, winSound, bgMusic];
    let loadedCount = 0;
    
    soundsToLoad.forEach(sound => {
      // Use a dummy event listener to preload sounds
      sound.addEventListener('canplaythrough', function onCanPlay() {
        loadedCount++;
        sound.removeEventListener('canplaythrough', onCanPlay);
        
        if (loadedCount === soundsToLoad.length) {
          soundsLoaded = true;
          // Don't auto-start music - wait for user interaction
        }
      });
      
      // Force load attempt
      sound.load();
    });
    
    // Fallback in case the events don't fire
    setTimeout(() => {
      if (!soundsLoaded) {
        soundsLoaded = true;
      }
    }, 3000);
    
    // Setup audio context for mobile
    setupAudioForMobile();
  }
  
  // Setup audio for mobile devices
  function setupAudioForMobile() {
    // Add a touch/click event listener to start audio on first interaction
    const startAudioOnInteraction = () => {
      if (!musicMuted) {
        console.log("Starting background music on first interaction");
        bgMusic.play().catch(e => console.log("Audio play failed:", e));
      }
      
      // Remove the event listeners after first interaction
      document.removeEventListener('touchstart', startAudioOnInteraction);
      document.removeEventListener('click', startAudioOnInteraction);
    };
    
    document.addEventListener('touchstart', startAudioOnInteraction);
    document.addEventListener('click', startAudioOnInteraction);
  }

  // Create the gift box character
  function createGiftBox() {
    // Gift box body
    const boxGeometry = new THREE.BoxGeometry(0.8, 0.8, 0.8);
    const boxMaterial = new THREE.MeshBasicMaterial({ color: 0xff69b4 }); // Hot pink
    giftBox = new THREE.Mesh(boxGeometry, boxMaterial);
    
    // Gift box ribbon (cross on top)
    const ribbonGeometry1 = new THREE.BoxGeometry(0.9, 0.1, 0.1);
    const ribbonGeometry2 = new THREE.BoxGeometry(0.1, 0.9, 0.1);
    const ribbonMaterial = new THREE.MeshBasicMaterial({ color: 0xffffff });
    
    const ribbonH = new THREE.Mesh(ribbonGeometry1, ribbonMaterial);
    ribbonH.position.set(0, 0, 0.45);
    
    const ribbonV = new THREE.Mesh(ribbonGeometry2, ribbonMaterial);
    ribbonV.position.set(0, 0, 0.45);
    
    // Create gift box group
    const giftBoxGroup = new THREE.Group();
    giftBoxGroup.add(giftBox);
    giftBoxGroup.add(ribbonH);
    giftBoxGroup.add(ribbonV);
    
    // Position at bottom of the screen
    giftBoxGroup.position.set(0, -gameHeight/2 + 0.5, 0);
    
    // Add collision geometry (for better hitbox)
    const hitboxSize = .75; // Increased from 0.7 to make hitbox bigger
    giftBoxGroup.userData.hitbox = new THREE.Box3(
      new THREE.Vector3(-hitboxSize/2, -hitboxSize/2, -hitboxSize/2),
      new THREE.Vector3(hitboxSize/2, hitboxSize/2, hitboxSize/2)
    );
    
    scene.add(giftBoxGroup);
    
    // Assign the group to giftBox for easier reference
    giftBox = giftBoxGroup;
    
    // Create debug visualization for hitbox
    createHitboxHelper(giftBox);
  }

  // Create finish line (hands)
  function createGoal() {
    // Simple placeholder for now - two hands at the top
    const handGeometry = new THREE.BoxGeometry(1, 0.5, 0.2);
    const handMaterial = new THREE.MeshBasicMaterial({ color: 0xffcc99 }); // Skin tone
    
    const leftHand = new THREE.Mesh(handGeometry, handMaterial);
    leftHand.position.set(-1.5, gameHeight/2 - 0.5, 0);
    
    const rightHand = new THREE.Mesh(handGeometry, handMaterial);
    rightHand.position.set(1.5, gameHeight/2 - 0.5, 0);
    
    scene.add(leftHand);
    scene.add(rightHand);
  }

  // Create obstacles
  function createObstacles() {
    // Clear existing obstacles
    obstacles.forEach(obstacle => scene.remove(obstacle));
    obstacles = [];
    clocksToRotate = [];
    
    // Clear any existing truck speed change timers
    truckSpeedChangeTimers.forEach(timer => clearTimeout(timer));
    truckSpeedChangeTimers = [];
    
    // Create 6 rows of obstacles (delivery vans, clocks, "out of stock" text)
    for (let i = 1; i < gameHeight - 1; i += 2) {
      const y = -gameHeight/2 + i + 1;
      
      // Randomly choose obstacle type
      const obstacleType = Math.floor(Math.random() * 3);
      let obstacle;
      
      switch (obstacleType) {
        case 0: // Delivery van
          obstacle = createDeliveryVan();
          setupTruckSpeedChanges(obstacle);
          break;
        case 1: // Clock
          obstacle = createClock();
          clocksToRotate.push(obstacle);
          break;
        case 2: // "Out of stock" text
          obstacle = createOutOfStock();
          break;
      }
      
      // Random starting position
      const x = Math.random() * gameWidth - gameWidth/2;
      obstacle.position.set(x, y, 0);
      
      // Random direction (1: right, -1: left)
      const direction = i % 4 === 0 ? -1 : 1;
      const baseSpeed = Math.random() * 0.05 + 0.02;
      
      obstacle.userData = {
        speed: baseSpeed * direction,
        baseSpeed: baseSpeed,
        direction: direction,
        type: obstacleType
      };
      
      // Add collision geometry based on obstacle type
      if (obstacleType === 0) { // Delivery van
        const hitboxWidth = 1.8; // Slightly smaller than visual size
        const hitboxHeight = 0.7;
        obstacle.userData.hitbox = new THREE.Box3(
          new THREE.Vector3(-hitboxWidth/2, -hitboxHeight/2, -0.4),
          new THREE.Vector3(hitboxWidth/2, hitboxHeight/2, 0.4)
        );
      } else if (obstacleType === 1) { // Clock
        const radius = 0.45; // Slightly smaller than visual size
        obstacle.userData.hitbox = new THREE.Box3(
          new THREE.Vector3(-radius, -radius, -0.1),
          new THREE.Vector3(radius, radius, 0.1)
        );
      } else { // Out of stock
        const hitboxSize = 0.9;
        obstacle.userData.hitbox = new THREE.Box3(
          new THREE.Vector3(-hitboxSize/2, -hitboxSize/2, -0.1),
          new THREE.Vector3(hitboxSize/2, hitboxSize/2, 0.1)
        );
      }
      
      obstacles.push(obstacle);
      scene.add(obstacle);
    }
  }

  // Setup random speed changes for trucks
  function setupTruckSpeedChanges(truck) {
    const createSpeedChange = () => {
      const timer = setTimeout(() => {
        // Random speed multiplier between 0.5 and 2
        const speedMultiplier = 0.5 + Math.random() * 1.5;
        truck.userData.speed = truck.userData.baseSpeed * truck.userData.direction * speedMultiplier;
        
        // Schedule next speed change
        const nextChangeTimer = createSpeedChange();
        truckSpeedChangeTimers.push(nextChangeTimer);
      }, 2000 + Math.random() * 3000); // Random time between 2-5 seconds
      
      return timer;
    };
    
    const initialTimer = createSpeedChange();
    truckSpeedChangeTimers.push(initialTimer);
  }

  // Create a delivery van obstacle
  function createDeliveryVan() {
    const van = new THREE.Group();
    
    // Van body
    const bodyGeometry = new THREE.BoxGeometry(2, 0.8, 0.8);
    const bodyMaterial = new THREE.MeshBasicMaterial({ color: 0x4285f4 }); // Blue
    const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
    
    // Wheels
    const wheelGeometry = new THREE.CylinderGeometry(0.2, 0.2, 0.1, 16);
    wheelGeometry.rotateX(Math.PI / 2);
    const wheelMaterial = new THREE.MeshBasicMaterial({ color: 0x222222 });
    
    const wheel1 = new THREE.Mesh(wheelGeometry, wheelMaterial);
    wheel1.position.set(-0.6, -0.4, 0);
    
    const wheel2 = new THREE.Mesh(wheelGeometry, wheelMaterial);
    wheel2.position.set(0.6, -0.4, 0);
    
    van.add(body);
    van.add(wheel1);
    van.add(wheel2);
    
    return van;
  }

  // Create a clock obstacle
  function createClock() {
    const clock = new THREE.Group();
    
    // Clock face
    const faceGeometry = new THREE.CircleGeometry(0.5, 32);
    const faceMaterial = new THREE.MeshBasicMaterial({ color: 0xffffff });
    const face = new THREE.Mesh(faceGeometry, faceMaterial);
    
    // Clock outline
    const outlineGeometry = new THREE.RingGeometry(0.48, 0.5, 32);
    const outlineMaterial = new THREE.MeshBasicMaterial({ color: 0x000000 });
    const outline = new THREE.Mesh(outlineGeometry, outlineMaterial);
    outline.position.set(0, 0, 0.01);
    
    // Clock hands
    const hourHandGeometry = new THREE.PlaneGeometry(0.05, 0.3);
    const hourHandMaterial = new THREE.MeshBasicMaterial({ color: 0x000000 });
    const hourHand = new THREE.Mesh(hourHandGeometry, hourHandMaterial);
    hourHand.position.set(0, 0, 0.02);
    hourHand.rotation.z = Math.random() * Math.PI * 2;
    
    const minuteHandGeometry = new THREE.PlaneGeometry(0.03, 0.4);
    const minuteHandMaterial = new THREE.MeshBasicMaterial({ color: 0x000000 });
    const minuteHand = new THREE.Mesh(minuteHandGeometry, minuteHandMaterial);
    minuteHand.position.set(0, 0, 0.03);
    minuteHand.rotation.z = Math.random() * Math.PI * 2;
    
    clock.add(face);
    clock.add(outline);
    clock.add(hourHand);
    clock.add(minuteHand);
    
    // Store references to hands for rotation
    clock.userData.hourHand = hourHand;
    clock.userData.minuteHand = minuteHand;
    clock.userData.rotationSpeed = {
      hour: 0.001 + Math.random() * 0.002,
      minute: 0.003 + Math.random() * 0.005
    };
    
    return clock;
  }

  // Create "Out of Stock" text
  function createOutOfStock() {
    const textGroup = new THREE.Group();
    
    // Background rectangle
    const bgGeometry = new THREE.PlaneGeometry(1.8, 0.8);
    const bgMaterial = new THREE.MeshBasicMaterial({ color: 0xffffff });
    const background = new THREE.Mesh(bgGeometry, bgMaterial);
    
    // Red border
    const borderGeometry = new THREE.RingGeometry(0.85, 0.9, 32);
    const borderMaterial = new THREE.MeshBasicMaterial({ color: 0xff0000 });
    const border = new THREE.Mesh(borderGeometry, borderMaterial);
    border.scale.set(1, 0.45, 1);
    border.position.set(0, 0, 0.01);
    
    // Red text (simplified as red bars)
    const line1Geometry = new THREE.PlaneGeometry(1.4, 0.1);
    const line1Material = new THREE.MeshBasicMaterial({ color: 0xff0000 });
    const line1 = new THREE.Mesh(line1Geometry, line1Material);
    line1.position.set(0, 0.15, 0.02);
    
    const line2Geometry = new THREE.PlaneGeometry(1.4, 0.1);
    const line2Material = new THREE.MeshBasicMaterial({ color: 0xff0000 });
    const line2 = new THREE.Mesh(line2Geometry, line2Material);
    line2.position.set(0, 0, 0.02);
    
    const line3Geometry = new THREE.PlaneGeometry(1.4, 0.1);
    const line3Material = new THREE.MeshBasicMaterial({ color: 0xff0000 });
    const line3 = new THREE.Mesh(line3Geometry, line3Material);
    line3.position.set(0, -0.15, 0.02);
    
    textGroup.add(background);
    textGroup.add(border);
    textGroup.add(line1);
    textGroup.add(line2);
    textGroup.add(line3);
    
    return textGroup;
  }

  // Create charge indicator
  function createChargeIndicator() {
    const geometry = new THREE.BoxGeometry(0.1, 0.5, 0.1);
    const material = new THREE.MeshBasicMaterial({ color: 0xff0000 });
    chargeIndicator = new THREE.Mesh(geometry, material);
    chargeIndicator.position.set(0.6, -gameHeight/2 + 0.5, 0);
    chargeIndicator.scale.set(1, 0, 1); // Start with no height
    scene.add(chargeIndicator);
  }

  // Start the game when the page loads
  window.onload = init;
</script> 