---
import Layout from "../layouts/Layout.astro";
---

<Layout title="Gifty Dodge - Help the gift reach its recipient!" hideHeader={true}>
  <div id="game-container"></div>
</Layout>

<style>
  body, html {
    margin: 0;
    padding: 0;
    overflow: hidden;
    width: 100%;
    height: 100%;
    touch-action: none;
    user-select: none;
    -webkit-user-select: none;
    -moz-user-select: none;
    -ms-user-select: none;
    -webkit-touch-callout: none;
  }
  
  #game-container {
    width: 100%;
    height: 100vh;
    display: block;
    position: absolute;
    top: 0;
    left: 0;
    user-select: none;
    -webkit-user-select: none;
    -moz-user-select: none;
    -ms-user-select: none;
    -webkit-touch-callout: none;
  }
  
  #level-indicator {
    position: fixed;
    bottom: 10px;
    left: 10px;
    background-color: rgba(255, 105, 180, 0.8);
    color: white;
    padding: 5px 10px;
    border-radius: 5px;
    font-size: 16px;
    font-weight: bold;
    z-index: 100;
    display: none; /* Hide the DOM version */
  }
</style>

<script>
  import * as THREE from 'three';

  // Prevent zoom and text selection on mobile
  document.addEventListener('touchstart', (e) => {
    if (e.touches.length > 1) {
      e.preventDefault();
    }
  }, { passive: false });
  
  document.addEventListener('touchmove', (e) => {
    e.preventDefault();
  }, { passive: false });

  // Game variables
  let scene, camera, renderer;
  let giftBox, grassField;
  let gameHeight = 15; // Number of jumps to win
  let currentPosition = 0;
  let gameWidth = 10; // Arbitrary width units
  let isJumping = false;
  let level = 1;
  let speedMultiplier = 1.0; // Base speed multiplier
  let obstacles = [];
  let clocksToRotate = [];
  let truckSpeedChangeTimers = [];
  let debugMode = true; // Enable debug visualization
  let hitboxHelpers = []; // Store hitbox visualizers
  let levelIndicator; // DOM element for level display
  let levelIndicator3D; // Three.js level indicator
  let congratsPopup; // Three.js popup for level completion
  
  // Three.js Audio
  let audioListener;
  let audioLoader;
  let jumpStartSound, jumpLandSound, collisionSound, winSound, bgMusic;
  let soundsLoaded = false;
  let musicMuted = false;
  let fxMuted = false;
  
  // Audio control buttons (Three.js objects)
  let musicButton, fxButton;
  let raycaster, mouse;
  
  // State machine
  const GameState = {
    IDLE: 'idle',
    CHARGING: 'charging',
    JUMPING: 'jumping',
    GAME_OVER: 'gameOver',
    LEVEL_COMPLETE: 'levelComplete'
  };
  
  let currentState = GameState.IDLE;
  let chargeStartTime = 0;
  let maxChargeTime = 500; // 1 second max charge
  let chargeStrength = 0;
  let chargeIndicator;

  // Initialize the game
  function init() {
    // Create scene
    scene = new THREE.Scene();
    scene.background = new THREE.Color(0xffe0f0); // Light pink background

    // Create camera (orthographic for top-down view)
    const aspect = window.innerWidth / window.innerHeight;
    const viewSize = 15;
    camera = new THREE.OrthographicCamera(
      -viewSize * aspect / 2, 
      viewSize * aspect / 2, 
      viewSize / 2, 
      -viewSize / 2, 
      0.1, 
      1000
    );
    camera.position.set(0, 0, 10);
    camera.lookAt(0, 0, 0);

    // Create renderer
    renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(window.devicePixelRatio);
    document.getElementById('game-container').appendChild(renderer.domElement);

    // Create level indicator
    createLevelIndicator();

    // Create grassy field
    const fieldGeometry = new THREE.PlaneGeometry(gameWidth, gameHeight);
    const fieldMaterial = new THREE.MeshBasicMaterial({ color: 0x66cc66 }); // Green color
    grassField = new THREE.Mesh(fieldGeometry, fieldMaterial);
    grassField.position.set(0, 0, -1);
    scene.add(grassField);

    // Initialize audio
    initAudio();

    // Create gift box character
    createGiftBox();
    
    // Create goal (hands)
    createGoal();
    
    // Add some initial obstacles
    createObstacles();

    // Create charge indicator
    createChargeIndicator();
    
    // Create Three.js audio control buttons
    createAudioButtons();
    
    // Create Three.js popup (initially hidden)
    createCongratsPopup();
    
    // Setup raycaster for button interaction
    raycaster = new THREE.Raycaster();
    mouse = new THREE.Vector2();
    
    // Handle window resize
    window.addEventListener('resize', onWindowResize);
    
    // Add touch/click event listener
    window.addEventListener('click', handleClick);
    window.addEventListener('mousedown', handleMouseDown);
    window.addEventListener('mouseup', handleMouseUp);
    window.addEventListener('mousemove', handleMouseMove);
    window.addEventListener('keydown', handleKeyDown);
    window.addEventListener('keyup', handleKeyUp);
    window.addEventListener('touchstart', function(e) {
      e.preventDefault();
      handleTouchStart(e);
    });
    window.addEventListener('touchend', function(e) {
      e.preventDefault();
      handleTouchEnd(e);
    });
    window.addEventListener('touchmove', function(e) {
      e.preventDefault();
      handleTouchMove(e);
    });

    // Start the animation loop
    animate();
  }
  
  // Initialize Three.js audio system
  function initAudio() {
    // Create audio listener and attach to camera
    audioListener = new THREE.AudioListener();
    camera.add(audioListener);
    
    // Create audio loader
    audioLoader = new THREE.AudioLoader();
    
    // Create sound objects
    jumpStartSound = new THREE.Audio(audioListener);
    jumpLandSound = new THREE.Audio(audioListener);
    collisionSound = new THREE.Audio(audioListener);
    winSound = new THREE.Audio(audioListener);
    
    // Create background music (positional audio for better control)
    bgMusic = new THREE.PositionalAudio(audioListener);
    
    // Load sound files
    let loadedCount = 0;
    const totalSounds = 5;
    
    // Helper function to track loading progress
    const onSoundLoaded = () => {
      loadedCount++;
      if (loadedCount === totalSounds) {
        soundsLoaded = true;
        console.log("All sounds loaded");
        
        // Setup audio for mobile after sounds are loaded
        setupAudioForMobile();
      }
    };
    
    // Load jump start sound
    audioLoader.load('/gifty-dodge/jump-press.mp3', function(buffer) {
      jumpStartSound.setBuffer(buffer);
      jumpStartSound.setVolume(1.0);
      onSoundLoaded();
    });
    
    // Load jump land sound
    audioLoader.load('/gifty-dodge/jump-release.mp3', function(buffer) {
      jumpLandSound.setBuffer(buffer);
      jumpLandSound.setVolume(1.0);
      onSoundLoaded();
    });
    
    // Load collision sound
    audioLoader.load('/gifty-dodge/ow.mp3', function(buffer) {
      collisionSound.setBuffer(buffer);
      collisionSound.setVolume(1.0);
      onSoundLoaded();
    });
    
    // Load win sound
    audioLoader.load('/gifty-dodge/yay.mp3', function(buffer) {
      winSound.setBuffer(buffer);
      winSound.setVolume(1.0);
      onSoundLoaded();
    });
    
    // Load background music
    audioLoader.load('/gifty-dodge/boba-date.mp3', function(buffer) {
      bgMusic.setBuffer(buffer);
      bgMusic.setVolume(0.25);
      bgMusic.setLoop(true);
      bgMusic.setRefDistance(20); // Adjust as needed
      
      // Add music to scene
      const musicDummy = new THREE.Object3D();
      musicDummy.position.set(0, 0, 0);
      musicDummy.add(bgMusic);
      scene.add(musicDummy);
      
      onSoundLoaded();
    });
    
    // Fallback in case loading takes too long
    setTimeout(() => {
      if (!soundsLoaded) {
        soundsLoaded = true;
        console.log("Sound loading timeout - proceeding anyway");
        
        // Setup audio for mobile even if timeout occurs
        setupAudioForMobile();
      }
    }, 5000);
  }
  
  // Create Three.js audio control buttons
  function createAudioButtons() {
    // Music button
    const musicGeometry = new THREE.CircleGeometry(0.4, 16);
    const musicMaterial = new THREE.MeshBasicMaterial({ 
      color: 0xf2f60d, // Yellow
      transparent: true,
      opacity: 0.8
    });
    musicButton = new THREE.Mesh(musicGeometry, musicMaterial);
    
    // Position in top-right corner of screen
    const aspect = window.innerWidth / window.innerHeight;
    const viewSize = 15;
    musicButton.position.set(viewSize * aspect / 2 - 0.5, viewSize / 2 - 1, 1);
    scene.add(musicButton);
    
    // Music icon (note symbol)
    const noteGeometry = new THREE.PlaneGeometry(0.8, 0.8);
    const noteTexture = new THREE.CanvasTexture(createTextureCanvas('ðŸŽµ'));
    const noteMaterial = new THREE.MeshBasicMaterial({ 
      map: noteTexture,
      transparent: true
    });
    const noteIcon = new THREE.Mesh(noteGeometry, noteMaterial);
    noteIcon.position.set(0, 0, 0.01);
    musicButton.add(noteIcon);
    
    // Add a highlight effect for better visual feedback
    const musicHighlightGeometry = new THREE.RingGeometry(0.8, 0.9, 32);
    const musicHighlightMaterial = new THREE.MeshBasicMaterial({
      color: 0xffffff,
      transparent: true,
      opacity: 0.5,
      side: THREE.DoubleSide
    });
    const musicHighlight = new THREE.Mesh(musicHighlightGeometry, musicHighlightMaterial);
    musicHighlight.position.set(0, 0, 0.005);
    musicHighlight.visible = false;
    musicButton.add(musicHighlight);
    
    // Store reference to icon for updating
    musicButton.userData = {
      icon: noteIcon,
      highlight: musicHighlight,
      type: 'music',
      muted: musicMuted,
      isHovered: false
    };
    
    // Update appearance if muted
    if (musicMuted) {
      musicButton.material.color.set(0x969696); // Gray
      noteIcon.material.map = new THREE.CanvasTexture(createTextureCanvas('ðŸ”‡'));
      noteIcon.material.needsUpdate = true;
    }
    
    // Sound effects button
    const fxGeometry = new THREE.CircleGeometry(0.4, 32);
    const fxMaterial = new THREE.MeshBasicMaterial({ 
      color: 0xf2f60d, // Yellow
      transparent: true,
      opacity: 0.8
    });
    fxButton = new THREE.Mesh(fxGeometry, fxMaterial);
    
    // Position next to music button
    fxButton.position.set(viewSize * aspect / 2 - 1.5, viewSize / 2 - 1, 1);
    scene.add(fxButton);
    
    // Sound icon
    const soundGeometry = new THREE.PlaneGeometry(0.8, 0.8);
    const soundTexture = new THREE.CanvasTexture(createTextureCanvas('ðŸ”Š'));
    const soundMaterial = new THREE.MeshBasicMaterial({ 
      map: soundTexture,
      transparent: true
    });
    const soundIcon = new THREE.Mesh(soundGeometry, soundMaterial);
    soundIcon.position.set(0, 0, 0.01);
    fxButton.add(soundIcon);
    
    // Add a highlight effect for better visual feedback
    const fxHighlightGeometry = new THREE.RingGeometry(0.8, 0.9, 32);
    const fxHighlightMaterial = new THREE.MeshBasicMaterial({
      color: 0xffffff,
      transparent: true,
      opacity: 0.5,
      side: THREE.DoubleSide
    });
    const fxHighlight = new THREE.Mesh(fxHighlightGeometry, fxHighlightMaterial);
    fxHighlight.position.set(0, 0, 0.005);
    fxHighlight.visible = false;
    fxButton.add(fxHighlight);
    
    // Store reference to icon for updating
    fxButton.userData = {
      icon: soundIcon,
      highlight: fxHighlight,
      type: 'fx',
      muted: fxMuted,
      isHovered: false
    };
    
    // Update appearance if muted
    if (fxMuted) {
      fxButton.material.color.set(0x969696); // Gray
      soundIcon.material.map = new THREE.CanvasTexture(createTextureCanvas('ðŸ”‡'));
      soundIcon.material.needsUpdate = true;
    }
    
    // Add a dedicated click handler for the buttons
    window.addEventListener('click', (e) => {
      checkButtonClick(e.clientX, e.clientY);
    });
  }
  
  // Create a canvas texture with emoji
  function createTextureCanvas(emoji) {
    const canvas = document.createElement('canvas');
    canvas.width = 128;
    canvas.height = 128;
    const ctx = canvas.getContext('2d');
    
    // Clear canvas
    ctx.fillStyle = 'rgba(0, 0, 0, 0)';
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    
    // Draw emoji
    ctx.fillStyle = 'white';
    ctx.font = '80px Arial';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText(emoji, canvas.width / 2, canvas.height / 2);
    
    return canvas;
  }
  
  // Handle button clicks
  function checkButtonClick(x, y) {
    console.log("Checking button click at:", x, y);
    
    // Convert screen coordinates to normalized device coordinates
    mouse.x = (x / window.innerWidth) * 2 - 1;
    mouse.y = -(y / window.innerHeight) * 2 + 1;
    
    console.log("Normalized coordinates:", mouse.x, mouse.y);
    
    // Update the picking ray with the camera and mouse position
    raycaster.setFromCamera(mouse, camera);
    
    // Get all interactive objects
    const interactiveObjects = [musicButton, fxButton];
    
    // Add popup button if popup is visible
    if (congratsPopup && congratsPopup.visible) {
      const popupButton = congratsPopup.children.find(child => child.userData && child.userData.isButton);
      if (popupButton) {
        interactiveObjects.push(popupButton);
      }
    }
    
    // Calculate objects intersecting the picking ray
    const intersects = raycaster.intersectObjects(interactiveObjects, true);
    
    console.log("Intersections found:", intersects.length);
    
    if (intersects.length > 0) {
      const button = intersects[0].object;
      console.log("Intersected object:", button);
      
      // Check if we hit a button or its child
      const targetButton = button.userData && (button.userData.type || button.userData.isButton || button.userData.isButtonText) 
        ? button 
        : button.parent;
      
      console.log("Target button:", targetButton);
      
      if (targetButton && targetButton.userData && targetButton.userData.type === 'music') {
        console.log("Music button clicked");
        // Visual feedback - scale animation
        animateButtonPress(musicButton);
        toggleMusic();
        return true;
      } else if (targetButton && targetButton.userData && targetButton.userData.type === 'fx') {
        console.log("FX button clicked");
        // Visual feedback - scale animation
        animateButtonPress(fxButton);
        toggleFx();
        return true;
      } else if (targetButton && (targetButton.userData.isButton || targetButton.userData.isButtonText)) {
        console.log("Popup button clicked");
        // Visual feedback - scale animation
        animateButtonPress(targetButton);
        // Hide popup and create new obstacles
        congratsPopup.visible = false;
        createObstacles();
        return true;
      }
    }
    
    return false;
  }
  
  // Check for button hover
  function checkButtonHover(x, y) {
    // Convert screen coordinates to normalized device coordinates
    mouse.x = (x / window.innerWidth) * 2 - 1;
    mouse.y = -(y / window.innerHeight) * 2 + 1;
    
    // Update the picking ray with the camera and mouse position
    raycaster.setFromCamera(mouse, camera);
    
    // Calculate objects intersecting the picking ray
    const intersects = raycaster.intersectObjects([musicButton, fxButton], true);
    
    // Reset hover states
    if (musicButton.userData.isHovered) {
      musicButton.userData.isHovered = false;
      musicButton.userData.highlight.visible = false;
    }
    
    if (fxButton.userData.isHovered) {
      fxButton.userData.isHovered = false;
      fxButton.userData.highlight.visible = false;
    }
    
    // Set hover state for intersected button
    if (intersects.length > 0) {
      const button = intersects[0].object;
      const targetButton = button.userData.type ? button : button.parent;
      
      targetButton.userData.isHovered = true;
      targetButton.userData.highlight.visible = true;
    }
  }
  
  // Animate button press
  function animateButtonPress(button) {
    // Save original scale
    const originalScale = button.scale.clone();
    
    // Scale down
    button.scale.set(0.9, 0.9, 0.9);
    
    // Scale back up after a short delay
    setTimeout(() => {
      button.scale.copy(originalScale);
    }, 100);
    
    // Add highlight effect for popup button
    if (button.userData && (button.userData.isButton || button.userData.isButtonText)) {
      // Change color temporarily
      const originalColor = button.material.color.clone();
      button.material.color.set(0xff4da6); // Lighter pink
      
      // Restore original color after delay
      setTimeout(() => {
        button.material.color.copy(originalColor);
      }, 100);
    }
  }
  
  // Toggle music
  function toggleMusic() {
    musicMuted = !musicMuted;
    console.log("Music toggle activated, new state:", musicMuted);
    
    if (musicMuted) {
      // Update button appearance
      musicButton.material.color.set(0x969696); // Gray
      const muteTexture = new THREE.CanvasTexture(createTextureCanvas('ðŸ”‡'));
      musicButton.userData.icon.material.map = muteTexture;
      musicButton.userData.icon.material.needsUpdate = true;
      
      // Pause background music
      if (bgMusic.isPlaying) {
        bgMusic.pause();
      }
      console.log("Music paused");
    } else {
      // Update button appearance
      musicButton.material.color.set(0xf2f60d); // Yellow
      const musicTexture = new THREE.CanvasTexture(createTextureCanvas('ðŸŽµ'));
      musicButton.userData.icon.material.map = musicTexture;
      musicButton.userData.icon.material.needsUpdate = true;
      
      // Play background music
      if (soundsLoaded && !bgMusic.isPlaying) {
        bgMusic.play();
      }
      console.log("Music playing");
    }
    
    musicButton.userData.muted = musicMuted;
  }
  
  // Toggle sound effects
  function toggleFx() {
    fxMuted = !fxMuted;
    console.log("FX toggle activated, new state:", fxMuted);
    
    if (fxMuted) {
      // Update button appearance
      fxButton.material.color.set(0x969696); // Gray
      const muteTexture = new THREE.CanvasTexture(createTextureCanvas('ðŸ”‡'));
      fxButton.userData.icon.material.map = muteTexture;
      fxButton.userData.icon.material.needsUpdate = true;
      
      // Mute sound effects
      jumpStartSound.setVolume(0);
      jumpLandSound.setVolume(0);
      collisionSound.setVolume(0);
      winSound.setVolume(0);
      console.log("FX muted");
    } else {
      // Update button appearance
      fxButton.material.color.set(0xf2f60d); // Yellow
      const fxTexture = new THREE.CanvasTexture(createTextureCanvas('ðŸ”Š'));
      fxButton.userData.icon.material.map = fxTexture;
      fxButton.userData.icon.material.needsUpdate = true;
      
      // Unmute sound effects
      jumpStartSound.setVolume(1);
      jumpLandSound.setVolume(1);
      collisionSound.setVolume(1);
      winSound.setVolume(1);
      console.log("FX unmuted");
    }
    
    fxButton.userData.muted = fxMuted;
  }

  // Handle mouse down event
  function handleMouseDown(e) {
    // Check if we clicked a button
    if (checkButtonClick(e.clientX, e.clientY)) {
      e.preventDefault();
      e.stopPropagation();
      return; // Button was clicked, don't process game action
    }
    
    if (currentState === GameState.IDLE) {
      startCharging();
    }
  }

  // Handle mouse up event
  function handleMouseUp(e) {
    if (currentState === GameState.CHARGING) {
      releaseJump();
    }
  }

  // Handle mouse move event for button hover
  function handleMouseMove(e) {
    checkButtonHover(e.clientX, e.clientY);
  }

  // Handle click event (for compatibility)
  function handleClick(e) {
    // Check if we clicked a button
    if (checkButtonClick(e.clientX, e.clientY)) {
      e.preventDefault();
      e.stopPropagation();
      return; // Button was clicked, don't process game action
    }
    
    // Only use this for devices that don't support mousedown/mouseup
    if (!('ontouchstart' in window) && !('onmousedown' in window)) {
      if (currentState === GameState.IDLE) {
        startCharging();
        // Simulate immediate release
        setTimeout(releaseJump, 100);
      }
    }
  }

  // Handle key down event
  function handleKeyDown(e) {
    if (currentState === GameState.IDLE) {
      startCharging();
    }
  }

  // Handle key up event
  function handleKeyUp(e) {
    if (currentState === GameState.CHARGING) {
      releaseJump();
    }
  }

  // Handle touch start event
  function handleTouchStart(e) {
    // Check if we touched a button
    if (e.touches.length > 0 && checkButtonClick(e.touches[0].clientX, e.touches[0].clientY)) {
      e.preventDefault();
      e.stopPropagation();
      return; // Button was touched, don't process game action
    }
    
    if (currentState === GameState.IDLE) {
      startCharging();
    }
  }

  // Handle touch end event
  function handleTouchEnd(e) {
    if (currentState === GameState.CHARGING) {
      releaseJump();
    }
  }

  // Handle touch move event for button hover
  function handleTouchMove(e) {
    if (e.touches.length > 0) {
      checkButtonHover(e.touches[0].clientX, e.touches[0].clientY);
    }
  }

  // Start charging the jump
  function startCharging() {
    currentState = GameState.CHARGING;
    chargeStartTime = Date.now();
    chargeStrength = 0;
    
    // Play jump start sound
    if (soundsLoaded && !fxMuted) {
      if (!jumpStartSound.isPlaying) {
        jumpStartSound.play();
      }
    }
    
    // Start charge animation
    animateCharging();
  }

  // Animate the charging state
  function animateCharging() {
    if (currentState === GameState.CHARGING) {
      const currentTime = Date.now();
      const elapsedTime = currentTime - chargeStartTime;
      
      // Calculate charge strength (0 to 1)
      chargeStrength = Math.min(elapsedTime / maxChargeTime, 1);
      
      // Update charge indicator
      chargeIndicator.scale.set(1, chargeStrength, 1);
      
      // Continue animation
      requestAnimationFrame(animateCharging);
    }
  }

  // Release the jump
  function releaseJump() {
    if (currentState === GameState.CHARGING) {
      currentState = GameState.JUMPING;
      
      // Reset charge indicator
      chargeIndicator.scale.set(1, 0, 1);
      
      // Play jump release sound
      if (soundsLoaded && !fxMuted) {
        if (!jumpLandSound.isPlaying) {
          jumpLandSound.play();
        }
      }
      
      // Execute jump with charge strength
      playerJump(chargeStrength);
    }
  }

  // Player jump function
  function playerJump(strength = 1) {
    if (currentState === GameState.JUMPING) {
      // Calculate jump distance based on strength with no minimum (pixel precision)
      const jumpDistance = strength * 1.5;
      const targetY = giftBox.position.y + jumpDistance;
      
      // Animation
      const jumpAnimation = () => {
        const jumpSpeed = 0.1 * (1 + strength); // Faster jump for stronger charge
        if (giftBox.position.y < targetY) {
          giftBox.position.y += jumpSpeed;
          requestAnimationFrame(jumpAnimation);
        } else {
          giftBox.position.y = Math.min(targetY, gameHeight/2 - 0.5); // Cap at top of screen
          currentState = GameState.IDLE;
          
          // Check if player reached the top
          if (giftBox.position.y >= gameHeight/2 - 1) {
            levelComplete();
          }
          
          // Check collision with obstacles
          checkCollisions();
        }
      };
      
      requestAnimationFrame(jumpAnimation);
    }
  }

  // Check for collisions with obstacles
  function checkCollisions() {
    // Create a box3 for the gift box at its current position
    const giftBoxHitbox = giftBox.userData.hitbox.clone();
    giftBoxHitbox.translate(giftBox.position);
    
    for (const obstacle of obstacles) {
      // Get the obstacle's hitbox at its current position
      const obstacleHitbox = obstacle.userData.hitbox.clone();
      obstacleHitbox.translate(obstacle.position);
      
      // Check for intersection
      if (giftBoxHitbox.intersectsBox(obstacleHitbox)) {
        // Collision detected - reset the game
        if (soundsLoaded && !fxMuted) {
          if (!collisionSound.isPlaying) {
            collisionSound.play();
          }
        }
        currentState = GameState.GAME_OVER;
        resetGame();
        break;
      }
    }
  }

  // Reset the game when player collides with obstacle
  function resetGame() {
    giftBox.position.set(0, -gameHeight/2 + 0.5, 0);
    currentState = GameState.IDLE;
  }

  // Complete the level
  function levelComplete() {
    level++;
    currentState = GameState.LEVEL_COMPLETE;
    
    // Increase speed multiplier by 3% for each level
    speedMultiplier = 1.0 + (level - 1) * 0.03;
    
    // Update level indicator
    if (levelIndicator) {
      levelIndicator.textContent = `Level: ${level}`;
    }
    
    // Update 3D level indicator
    updateLevelIndicator3D();
    
    // Play win sound
    if (soundsLoaded && !fxMuted) {
      if (!winSound.isPlaying) {
        winSound.play();
      }
    }
    
    // Update and show Three.js popup
    updateCongratsPopup(level - 1);
    congratsPopup.visible = true;
    
    resetGame();
  }
  
  // Update the congrats popup message
  function updateCongratsPopup(completedLevel) {
    // Find the message mesh
    const messageMesh = congratsPopup.children.find(child => child.userData && child.userData.isMessageText);
    
    if (messageMesh) {
      // Create new canvas for updated message
      const messageCanvas = document.createElement('canvas');
      messageCanvas.width = 512;
      messageCanvas.height = 128;
      const messageCtx = messageCanvas.getContext('2d');
      
      // Clear canvas
      messageCtx.fillStyle = 'rgba(255, 255, 255, 0)';
      messageCtx.fillRect(0, 0, messageCanvas.width, messageCanvas.height);
      
      // Draw updated message
      messageCtx.fillStyle = '#333333';
      messageCtx.font = '40px Arial';
      messageCtx.textAlign = 'center';
      messageCtx.textBaseline = 'middle';
      messageCtx.fillText(`You completed level ${completedLevel}!`, messageCanvas.width/2, messageCanvas.height/2);
      
      // Update texture
      if (messageMesh.material.map) {
        messageMesh.material.map.dispose();
      }
      messageMesh.material.map = new THREE.CanvasTexture(messageCanvas);
      messageMesh.material.needsUpdate = true;
    }
  }

  // Handle window resize
  function onWindowResize() {
    const aspect = window.innerWidth / window.innerHeight;
    const viewSize = 15;
    
    camera.left = -viewSize * aspect / 2;
    camera.right = viewSize * aspect / 2;
    camera.top = viewSize / 2;
    camera.bottom = -viewSize / 2;
    
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(window.devicePixelRatio);
    
    // Update level indicator position
    if (levelIndicator3D) {
      levelIndicator3D.position.set(-viewSize * aspect / 2 + 1, -viewSize / 2 + 0.5, 1);
    }
  }

  // Animation loop
  function animate() {
    requestAnimationFrame(animate);
    
    // Move obstacles
    obstacles.forEach(obstacle => {
      obstacle.position.x += obstacle.userData.speed;
      
      // Wrap around screen edges
      if (obstacle.position.x > gameWidth/2 + 1) {
        obstacle.position.x = -gameWidth/2 - 1;
      } else if (obstacle.position.x < -gameWidth/2 - 1) {
        obstacle.position.x = gameWidth/2 + 1;
      }
      
      // Rotate clock objects as they move
      if (obstacle.userData.type === 1) { // Clock type
        obstacle.rotation.z += obstacle.userData.speed * -1.0; // Rotate based on movement speed
      }
      
      // Update hitbox helper position
      updateHitboxHelper(obstacle);
      
      // Check for collisions during movement
      if (currentState !== GameState.GAME_OVER && currentState !== GameState.LEVEL_COMPLETE) {
        const giftBoxHitbox = giftBox.userData.hitbox.clone();
        giftBoxHitbox.translate(giftBox.position);
        
        const obstacleHitbox = obstacle.userData.hitbox.clone();
        obstacleHitbox.translate(obstacle.position);
        
        if (giftBoxHitbox.intersectsBox(obstacleHitbox)) {
          // Collision detected during movement
          if (soundsLoaded && !fxMuted) {
            if (!collisionSound.isPlaying) {
              collisionSound.play();
            }
          }
          currentState = GameState.GAME_OVER;
          resetGame();
        }
      }
    });
    
    // Rotate clock hands
    clocksToRotate.forEach(clock => {
      if (clock.userData.hourHand && clock.userData.minuteHand) {
        clock.userData.hourHand.rotation.z += clock.userData.rotationSpeed.hour;
        clock.userData.minuteHand.rotation.z += clock.userData.rotationSpeed.minute;
      }
    });
    
    // Update charge indicator position to follow gift box horizontally
    if (chargeIndicator) {
      chargeIndicator.position.x = giftBox.position.x + 0.6;
      chargeIndicator.position.y = giftBox.position.y;
    }
    
    // Update gift box hitbox helper
    updateHitboxHelper(giftBox);
    
    renderer.render(scene, camera);
  }

  // Create a visual helper for hitboxes
  function createHitboxHelper(object) {
    if (!object.userData.hitbox) return;
    
    const box = object.userData.hitbox.clone();
    const size = box.getSize(new THREE.Vector3());
    
    const geometry = new THREE.BoxGeometry(size.x, size.y, size.z);
    const material = new THREE.MeshBasicMaterial({ 
      color: 0xff0000, 
      wireframe: true,
      transparent: true,
      opacity: 0.5
    });
    
    const helper = new THREE.Mesh(geometry, material);
    helper.visible = debugMode;
    
    // Store reference to the object this helper belongs to
    helper.userData.targetObject = object;
    
    // Position helper at the center of the hitbox
    const center = box.getCenter(new THREE.Vector3());
    helper.position.copy(center);
    
    scene.add(helper);
    hitboxHelpers.push(helper);
    
    return helper;
  }
  
  // Update hitbox helper position
  function updateHitboxHelper(object) {
    const helper = hitboxHelpers.find(h => h.userData.targetObject === object);
    if (!helper) return;
    
    const hitbox = object.userData.hitbox.clone();
    hitbox.translate(object.position);
    
    const center = hitbox.getCenter(new THREE.Vector3());
    helper.position.copy(center);
  }
  
  // Toggle debug visuals
  function updateDebugVisuals() {
    hitboxHelpers.forEach(helper => {
      helper.visible = debugMode;
    });
  }

  // Setup audio for mobile devices
  function setupAudioForMobile() {
    console.log("Setting up audio for mobile/first interaction");
    
    // Create a function to unlock audio context
    const unlockAudioContext = () => {
      // Resume the audio context if it's suspended
      if (audioListener.context.state === 'suspended') {
        audioListener.context.resume().then(() => {
          console.log("AudioContext resumed successfully");
        });
      }
      
      // Start background music if not muted
      if (!musicMuted && soundsLoaded) {
        console.log("Starting background music on first interaction");
        if (!bgMusic.isPlaying) {
          bgMusic.play();
        }
      }
      
      // Remove the event listeners after first interaction
      document.removeEventListener('touchstart', unlockAudioContext, true);
      document.removeEventListener('touchend', unlockAudioContext, true);
      document.removeEventListener('click', unlockAudioContext, true);
      document.removeEventListener('keydown', unlockAudioContext, true);
    };
    
    // Add event listeners for user interaction
    document.addEventListener('touchstart', unlockAudioContext, true);
    document.addEventListener('touchend', unlockAudioContext, true);
    document.addEventListener('click', unlockAudioContext, true);
    document.addEventListener('keydown', unlockAudioContext, true);
    
    // Try to unlock immediately if possible
    unlockAudioContext();
  }

  // Create the gift box character
  function createGiftBox() {
    // Gift box body
    const boxGeometry = new THREE.BoxGeometry(0.8, 0.8, 0.8);
    const boxMaterial = new THREE.MeshBasicMaterial({ color: 0xff69b4 }); // Hot pink
    giftBox = new THREE.Mesh(boxGeometry, boxMaterial);
    
    // Gift box ribbon (cross on top)
    const ribbonGeometry1 = new THREE.BoxGeometry(0.9, 0.1, 0.1);
    const ribbonGeometry2 = new THREE.BoxGeometry(0.1, 0.9, 0.1);
    const ribbonMaterial = new THREE.MeshBasicMaterial({ color: 0xffffff });
    
    const ribbonH = new THREE.Mesh(ribbonGeometry1, ribbonMaterial);
    ribbonH.position.set(0, 0, 0.45);
    
    const ribbonV = new THREE.Mesh(ribbonGeometry2, ribbonMaterial);
    ribbonV.position.set(0, 0, 0.45);
    
    // Create gift box group
    const giftBoxGroup = new THREE.Group();
    giftBoxGroup.add(giftBox);
    giftBoxGroup.add(ribbonH);
    giftBoxGroup.add(ribbonV);
    
    // Position at bottom of the screen
    giftBoxGroup.position.set(0, -gameHeight/2 + 0.5, 0);
    
    // Add collision geometry (for better hitbox)
    const hitboxSize = .75; // Increased from 0.7 to make hitbox bigger
    giftBoxGroup.userData.hitbox = new THREE.Box3(
      new THREE.Vector3(-hitboxSize/2, -hitboxSize/2, -hitboxSize/2),
      new THREE.Vector3(hitboxSize/2, hitboxSize/2, hitboxSize/2)
    );
    
    scene.add(giftBoxGroup);
    
    // Assign the group to giftBox for easier reference
    giftBox = giftBoxGroup;
    
    // Create debug visualization for hitbox
    createHitboxHelper(giftBox);
  }

  // Create finish line (hands)
  function createGoal() {
    // Create a more detailed hand model
    const handGroup = new THREE.Group();
    
    // Palm
    const palmGeometry = new THREE.BoxGeometry(1, 0.6, 0.2);
    const skinMaterial = new THREE.MeshBasicMaterial({ color: 0xffcc99 }); // Skin tone
    const palm = new THREE.Mesh(palmGeometry, skinMaterial);
    handGroup.add(palm);
    
    // Fingers
    for (let i = 0; i < 4; i++) {
      const fingerGeometry = new THREE.BoxGeometry(0.15, 0.4, 0.15);
      const finger = new THREE.Mesh(fingerGeometry, skinMaterial);
      finger.position.set(-0.35 + i * 0.23, 0.5, 0);
      handGroup.add(finger);
    }
    
    // Thumb
    const thumbGeometry = new THREE.BoxGeometry(0.15, 0.3, 0.15);
    const thumb = new THREE.Mesh(thumbGeometry, skinMaterial);
    thumb.position.set(-0.55, 0.2, 0);
    thumb.rotation.z = Math.PI / 4;
    handGroup.add(thumb);
    
    // Create left and right hands
    const leftHand = handGroup.clone();
    leftHand.position.set(-1.5, gameHeight/2 - 0.5, 0);
    leftHand.rotation.z = Math.PI; // Rotate 180 degrees
    
    const rightHand = handGroup.clone();
    rightHand.scale.x = -1; // Mirror for right hand
    rightHand.position.set(1.5, gameHeight/2 - 0.5, 0);
    rightHand.rotation.z = Math.PI; // Rotate 180 degrees
    
    scene.add(leftHand);
    scene.add(rightHand);
  }

  // Create obstacles
  function createObstacles() {
    // Clear existing obstacles
    obstacles.forEach(obstacle => scene.remove(obstacle));
    obstacles = [];
    clocksToRotate = [];
    
    // Clear any existing truck speed change timers
    truckSpeedChangeTimers.forEach(timer => clearTimeout(timer));
    truckSpeedChangeTimers = [];
    
    // Create 6 rows of obstacles (delivery vans, clocks, "out of stock" text)
    for (let i = 1; i < gameHeight - 1; i += 2) {
      const y = -gameHeight/2 + i + 1;
      
      // Randomly choose obstacle type
      const obstacleType = Math.floor(Math.random() * 3);
      let obstacle;
      
      switch (obstacleType) {
        case 0: // Delivery van
          obstacle = createDeliveryVan();
          setupTruckSpeedChanges(obstacle);
          break;
        case 1: // Clock
          obstacle = createClock();
          clocksToRotate.push(obstacle);
          break;
        case 2: // "Out of stock" text
          obstacle = createOutOfStock();
          break;
      }
      
      // Random starting position
      const x = Math.random() * gameWidth - gameWidth/2;
      obstacle.position.set(x, y, 0);
      
      // Random direction (1: right, -1: left)
      const direction = i % 4 === 0 ? -1 : 1;
      const baseSpeed = (Math.random() * 0.05 + 0.02) * speedMultiplier;
      
      obstacle.userData = {
        speed: baseSpeed * direction,
        baseSpeed: baseSpeed,
        direction: direction,
        type: obstacleType
      };
      
      // Add collision geometry based on obstacle type
      if (obstacleType === 0) { // Delivery van
        const hitboxWidth = 1.8; // Slightly smaller than visual size
        const hitboxHeight = 0.7;
        obstacle.userData.hitbox = new THREE.Box3(
          new THREE.Vector3(-hitboxWidth/2, -hitboxHeight/2, -0.4),
          new THREE.Vector3(hitboxWidth/2, hitboxHeight/2, 0.4)
        );
      } else if (obstacleType === 1) { // Clock
        const radius = 0.45; // Slightly smaller than visual size
        obstacle.userData.hitbox = new THREE.Box3(
          new THREE.Vector3(-radius, -radius, -0.1),
          new THREE.Vector3(radius, radius, 0.1)
        );
      } else { // Out of stock
        const hitboxSize = 0.9;
        obstacle.userData.hitbox = new THREE.Box3(
          new THREE.Vector3(-hitboxSize/2, -hitboxSize/2, -0.1),
          new THREE.Vector3(hitboxSize/2, hitboxSize/2, 0.1)
        );
      }
      
      obstacles.push(obstacle);
      scene.add(obstacle);
    }
  }

  // Setup random speed changes for trucks
  function setupTruckSpeedChanges(truck) {
    const createSpeedChange = () => {
      const timer = setTimeout(() => {
        // Random speed multiplier between 0.5 and 2
        const randomSpeedMultiplier = 0.5 + Math.random() * 1.5;
        truck.userData.speed = truck.userData.baseSpeed * truck.userData.direction * randomSpeedMultiplier;
        
        // Schedule next speed change
        const nextChangeTimer = createSpeedChange();
        truckSpeedChangeTimers.push(nextChangeTimer);
      }, 2000 + Math.random() * 3000); // Random time between 2-5 seconds
      
      return timer;
    };
    
    const initialTimer = createSpeedChange();
    truckSpeedChangeTimers.push(initialTimer);
  }

  // Create a delivery van obstacle
  function createDeliveryVan() {
    const van = new THREE.Group();
    
    // Van body
    const bodyGeometry = new THREE.BoxGeometry(2, 0.8, 0.8);
    const bodyMaterial = new THREE.MeshBasicMaterial({ color: 0x4285f4 }); // Blue
    const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
    
    // Windshield - moved to the other side
    const windshieldGeometry = new THREE.PlaneGeometry(0.6, 0.4);
    const windshieldMaterial = new THREE.MeshBasicMaterial({ color: 0xadd8e6 }); // Light blue
    const windshield = new THREE.Mesh(windshieldGeometry, windshieldMaterial);
    windshield.position.set(0.5, 0.1, 0.41); // Changed from -0.5 to 0.5
    
    // Windshield frame
    const frameGeometry = new THREE.BoxGeometry(0.65, 0.45, 0.02);
    const frameMaterial = new THREE.MeshBasicMaterial({ color: 0x333333 });
    const frame = new THREE.Mesh(frameGeometry, frameMaterial);
    frame.position.set(0.5, 0.1, 0.4); // Changed from -0.5 to 0.5
    
    // Wheels
    const wheelGeometry = new THREE.CylinderGeometry(0.2, 0.2, 0.1, 16);
    wheelGeometry.rotateX(Math.PI / 2);
    const wheelMaterial = new THREE.MeshBasicMaterial({ color: 0x222222 });
    
    const wheel1 = new THREE.Mesh(wheelGeometry, wheelMaterial);
    wheel1.position.set(-0.6, -0.4, 0);
    
    const wheel2 = new THREE.Mesh(wheelGeometry, wheelMaterial);
    wheel2.position.set(0.6, -0.4, 0);
    
    van.add(body);
    van.add(frame);
    van.add(windshield);
    van.add(wheel1);
    van.add(wheel2);
    
    return van;
  }

  // Create a clock obstacle
  function createClock() {
    const clock = new THREE.Group();
    
    // Clock face
    const faceGeometry = new THREE.CircleGeometry(0.5, 32);
    const faceMaterial = new THREE.MeshBasicMaterial({ color: 0xffffff });
    const face = new THREE.Mesh(faceGeometry, faceMaterial);
    
    // Clock outline
    const outlineGeometry = new THREE.RingGeometry(0.48, 0.5, 32);
    const outlineMaterial = new THREE.MeshBasicMaterial({ color: 0x000000 });
    const outline = new THREE.Mesh(outlineGeometry, outlineMaterial);
    outline.position.set(0, 0, 0.01);
    
    // Clock hands
    const hourHandGeometry = new THREE.PlaneGeometry(0.05, 0.3);
    const hourHandMaterial = new THREE.MeshBasicMaterial({ color: 0x000000 });
    const hourHand = new THREE.Mesh(hourHandGeometry, hourHandMaterial);
    hourHand.position.set(0, 0.025, 0.02);
    hourHand.rotation.z = Math.random() * Math.PI * 2;
    
    const minuteHandGeometry = new THREE.PlaneGeometry(0.03, 0.4);
    const minuteHandMaterial = new THREE.MeshBasicMaterial({ color: 0x000000 });
    const minuteHand = new THREE.Mesh(minuteHandGeometry, minuteHandMaterial);
    minuteHand.position.set(0, 0.15, 0.03);
    minuteHand.rotation.z = Math.random() * Math.PI * 2;
    
    clock.add(face);
    clock.add(outline);
    clock.add(hourHand);
    clock.add(minuteHand);
    
    // Store references to hands for rotation
    clock.userData.hourHand = hourHand;
    clock.userData.minuteHand = minuteHand;
    clock.userData.rotationSpeed = {
      hour: 0.001 + Math.random() * 0.002,
      minute: 0.003 + Math.random() * 0.005
    };
    
    return clock;
  }

  // Create "Out of Stock" text
  function createOutOfStock() {
    const textGroup = new THREE.Group();
    
    // Background rectangle - reduced width
    const bgGeometry = new THREE.PlaneGeometry(1.4, 0.8); // Changed from 1.8 to 1.4
    const bgMaterial = new THREE.MeshBasicMaterial({ color: 0xffffff });
    const background = new THREE.Mesh(bgGeometry, bgMaterial);
    
    // Red border - reduced width
    const borderGeometry = new THREE.PlaneGeometry(1.4, 0.8); // Changed from 1.8 to 1.4
    const borderMaterial = new THREE.MeshBasicMaterial({ 
      color: 0xff0000,
      transparent: true,
      opacity: 0.2
    });
    const border = new THREE.Mesh(borderGeometry, borderMaterial);
    border.position.set(0, 0, 0.01);
    
    // Create text using canvas texture
    const canvas = document.createElement('canvas');
    canvas.width = 256;
    canvas.height = 128;
    const ctx = canvas.getContext('2d');
    
    // Clear canvas
    ctx.fillStyle = 'rgba(255, 255, 255, 0)';
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    
    // Draw text - stacked vertically to take less horizontal space
    ctx.fillStyle = '#ff0000';
    ctx.font = 'bold 32px Arial'; // Slightly smaller font
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText('OUT', canvas.width/2, canvas.height/2 - 30);
    ctx.fillText('OF', canvas.width/2, canvas.height/2);
    ctx.fillText('STOCK', canvas.width/2, canvas.height/2 + 30);
    
    // Create texture from canvas
    const texture = new THREE.CanvasTexture(canvas);
    const textMaterial = new THREE.MeshBasicMaterial({
      map: texture,
      transparent: true
    });
    
    // Reduced width
    const textPlane = new THREE.PlaneGeometry(1.2, 0.7); // Changed from 1.6 to 1.2
    const textMesh = new THREE.Mesh(textPlane, textMaterial);
    textMesh.position.set(0, 0, 0.02);
    
    textGroup.add(background);
    textGroup.add(border);
    textGroup.add(textMesh);
    
    return textGroup;
  }

  // Create charge indicator
  function createChargeIndicator() {
    const geometry = new THREE.BoxGeometry(0.1, 0.5, 0.1);
    const material = new THREE.MeshBasicMaterial({ color: 0xff0000 });
    chargeIndicator = new THREE.Mesh(geometry, material);
    chargeIndicator.position.set(0.6, -gameHeight/2 + 0.5, 0);
    chargeIndicator.scale.set(1, 0, 1); // Start with no height
    scene.add(chargeIndicator);
  }

  // Create level indicator
  function createLevelIndicator() {
    // Create DOM element for level indicator (keep for fallback)
    levelIndicator = document.createElement('div');
    levelIndicator.id = 'level-indicator';
    levelIndicator.textContent = `Level: ${level}`;
    document.body.appendChild(levelIndicator);
    
    // Create 3D level indicator
    levelIndicator3D = new THREE.Group();
    
    // Background rectangle
    const bgGeometry = new THREE.PlaneGeometry(1.6, 0.6);
    const bgMaterial = new THREE.MeshBasicMaterial({ 
      color: 0xff69b4,
      transparent: true,
      opacity: 0.8
    });
    const background = new THREE.Mesh(bgGeometry, bgMaterial);
    
    // Add border
    const borderGeometry = new THREE.PlaneGeometry(1.65, 0.65);
    const borderMaterial = new THREE.MeshBasicMaterial({ 
      color: 0xffffff,
      transparent: true,
      opacity: 0.5
    });
    const border = new THREE.Mesh(borderGeometry, borderMaterial);
    border.position.set(0, 0, -0.01);
    
    levelIndicator3D.add(border);
    levelIndicator3D.add(background);
    
    // Create text using canvas texture
    updateLevelIndicator3D();
    
    // Position at bottom left
    const aspect = window.innerWidth / window.innerHeight;
    const viewSize = 15;
    levelIndicator3D.position.set(-viewSize * aspect / 2 + 1, -viewSize / 2 + 0.5, 1);
    
    scene.add(levelIndicator3D);
  }
  
  // Update the 3D level indicator text
  function updateLevelIndicator3D() {
    // Remove old text if it exists
    if (levelIndicator3D) {
      const oldText = levelIndicator3D.children.find(child => child.userData && child.userData.isLevelText);
      if (oldText) {
        levelIndicator3D.remove(oldText);
      }
      
      // Create text using canvas texture
      const canvas = document.createElement('canvas');
      canvas.width = 256;
      canvas.height = 128;
      const ctx = canvas.getContext('2d');
      
      // Clear canvas
      ctx.fillStyle = 'rgba(255, 255, 255, 0)';
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      
      // Draw text
      ctx.fillStyle = '#ffffff';
      ctx.font = 'bold 40px Arial';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText(`LEVEL: ${level}`, canvas.width/2, canvas.height/2);
      
      // Create texture from canvas
      const texture = new THREE.CanvasTexture(canvas);
      const textMaterial = new THREE.MeshBasicMaterial({
        map: texture,
        transparent: true
      });
      
      const textPlane = new THREE.PlaneGeometry(1.5, 0.5);
      const textMesh = new THREE.Mesh(textPlane, textMaterial);
      textMesh.position.set(0, 0, 0.01);
      textMesh.userData = { isLevelText: true };
      
      levelIndicator3D.add(textMesh);
    }
  }

  // Create Three.js popup (initially hidden)
  function createCongratsPopup() {
    // Create a new group for the popup
    congratsPopup = new THREE.Group();
    
    // Create a background rectangle with pink border
    const bgGeometry = new THREE.PlaneGeometry(6, 4);
    const bgMaterial = new THREE.MeshBasicMaterial({ color: 0xffe0f0 }); // Light pink
    const bgMesh = new THREE.Mesh(bgGeometry, bgMaterial);
    congratsPopup.add(bgMesh);
    
    // Add border
    const borderGeometry = new THREE.PlaneGeometry(6.2, 4.2);
    const borderMaterial = new THREE.MeshBasicMaterial({ 
      color: 0xff69b4, // Hot pink
      transparent: true,
      opacity: 0.8
    });
    const borderMesh = new THREE.Mesh(borderGeometry, borderMaterial);
    borderMesh.position.z = -0.01;
    congratsPopup.add(borderMesh);
    
    // Create title text
    const titleCanvas = document.createElement('canvas');
    titleCanvas.width = 512;
    titleCanvas.height = 128;
    const titleCtx = titleCanvas.getContext('2d');
    
    // Clear canvas
    titleCtx.fillStyle = 'rgba(255, 255, 255, 0)';
    titleCtx.fillRect(0, 0, titleCanvas.width, titleCanvas.height);
    
    // Draw title
    titleCtx.fillStyle = '#ff69b4'; // Hot pink
    titleCtx.font = 'bold 60px Arial';
    titleCtx.textAlign = 'center';
    titleCtx.textBaseline = 'middle';
    titleCtx.fillText('CONGRATULATIONS!', titleCanvas.width/2, titleCanvas.height/2);
    
    // Create texture from canvas
    const titleTexture = new THREE.CanvasTexture(titleCanvas);
    const titleMaterial = new THREE.MeshBasicMaterial({
      map: titleTexture,
      transparent: true
    });
    
    // Create title mesh
    const titlePlane = new THREE.PlaneGeometry(5, 1);
    const titleMesh = new THREE.Mesh(titlePlane, titleMaterial);
    titleMesh.position.set(0, 1, 0.01);
    
    congratsPopup.add(titleMesh);
    
    // Create message text (will be updated for each level)
    const messageCanvas = document.createElement('canvas');
    messageCanvas.width = 512;
    messageCanvas.height = 128;
    const messageCtx = messageCanvas.getContext('2d');
    
    // Clear canvas
    messageCtx.fillStyle = 'rgba(255, 255, 255, 0)';
    messageCtx.fillRect(0, 0, messageCanvas.width, messageCanvas.height);
    
    // Draw message
    messageCtx.fillStyle = '#333333';
    messageCtx.font = '40px Arial';
    messageCtx.textAlign = 'center';
    messageCtx.textBaseline = 'middle';
    messageCtx.fillText(`You completed level ${level}!`, messageCanvas.width/2, messageCanvas.height/2);
    
    // Create texture from canvas
    const messageTexture = new THREE.CanvasTexture(messageCanvas);
    const messageMaterial = new THREE.MeshBasicMaterial({
      map: messageTexture,
      transparent: true
    });
    
    // Create message mesh
    const messagePlane = new THREE.PlaneGeometry(5, 1);
    const messageMesh = new THREE.Mesh(messagePlane, messageMaterial);
    messageMesh.position.set(0, 0, 0.01);
    messageMesh.userData = { isMessageText: true };
    
    congratsPopup.add(messageMesh);
    
    // Create button
    const buttonGeometry = new THREE.PlaneGeometry(2.5, 0.8);
    const buttonMaterial = new THREE.MeshBasicMaterial({ color: 0xff69b4 }); // Hot pink
    const buttonMesh = new THREE.Mesh(buttonGeometry, buttonMaterial);
    buttonMesh.position.set(0, -1, 0.01);
    buttonMesh.userData = { isButton: true };
    
    congratsPopup.add(buttonMesh);
    
    // Create button text
    const buttonCanvas = document.createElement('canvas');
    buttonCanvas.width = 256;
    buttonCanvas.height = 128;
    const buttonCtx = buttonCanvas.getContext('2d');
    
    // Clear canvas
    buttonCtx.fillStyle = 'rgba(255, 255, 255, 0)';
    buttonCtx.fillRect(0, 0, buttonCanvas.width, buttonCanvas.height);
    
    // Draw button text
    buttonCtx.fillStyle = '#ffffff';
    buttonCtx.font = 'bold 40px Arial';
    buttonCtx.textAlign = 'center';
    buttonCtx.textBaseline = 'middle';
    buttonCtx.fillText('NEXT LEVEL', buttonCanvas.width/2, buttonCanvas.height/2);
    
    // Create texture from canvas
    const buttonTexture = new THREE.CanvasTexture(buttonCanvas);
    const buttonTextMaterial = new THREE.MeshBasicMaterial({
      map: buttonTexture,
      transparent: true
    });
    
    // Create button text mesh
    const buttonTextPlane = new THREE.PlaneGeometry(2.4, 0.7);
    const buttonTextMesh = new THREE.Mesh(buttonTextPlane, buttonTextMaterial);
    buttonTextMesh.position.set(0, 0, 0.01);
    buttonTextMesh.userData = { isButtonText: true };
    
    buttonMesh.add(buttonTextMesh);
    
    // Position the popup in front of everything
    congratsPopup.position.set(0, 0, 5);
    congratsPopup.visible = false;
    
    // Add the popup to the scene
    scene.add(congratsPopup);
  }

  // Start the game when the page loads
  window.onload = init;
</script> 