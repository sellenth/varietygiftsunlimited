---
import Header from "../components/Header.astro";
---
<style>
  html, body {
    margin: 0;
    padding: 0;
    overflow: hidden;
    height: 100%;
  }
  #high-score {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    font-size: 20vw; /* Giant size relative to viewport width */
    color: rgba(48, 25, 52, 0.2); /* Dark purple with transparency */
    z-index: -1; /* Ensure it's behind other elements */
    pointer-events: none; /* Prevent interaction */
  }
  .instructions {
    transition: opacity 0.5s ease;
  }
  .hidden {
    opacity: 0;
    visibility: hidden;
  }
</style>
<Header />
<div id="game">
    <div id="high-score">0</div>
    <p id="instructions" class="instructions">Get ready to fly as a stack of money with wings!</p>
    <div id="score-counter" style="position: absolute; bottom: 20px; left: 20px; color: white;">
      <small>Score</small>
      <h1 id="score" style="margin: 0;">0</h1>
    </div>
    <script>
        try {
            const canvas = document.createElement('canvas');
            const context = canvas.getContext('2d');
            document.getElementById('game').appendChild(canvas);
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight - document.querySelector('header').offsetHeight;

            let stack = { x: canvas.width / 2, y: 150, width: 50, height: 50, gravity: 0.6, lift: -15, velocity: 0 };
            let obstacles = [];
            let score = 0;
            let scoredObstacles = new Set();

            function drawStack() {
                context.fillStyle = 'gold';
                context.fillRect(stack.x, stack.y, stack.width, stack.height);
            }

            function drawObstacles() {
                context.fillStyle = 'green';
                obstacles.forEach(obstacle => {
                    context.fillRect(obstacle.x, 0, obstacle.width, obstacle.height);
                    context.fillRect(obstacle.x, obstacle.height + 150, obstacle.width, canvas.height - obstacle.height - 150);
                });
            }

            function updateObstacles() {
                if (frames % 75 === 0) {
                    obstacles.push({ x: canvas.width, width: 50, height: Math.random() * (canvas.height - 150) / 2 });
                }
                obstacles.forEach((obstacle, index) => {
                    obstacle.x -= 5;
                    if (obstacle.x + obstacle.width < 0) {
                        obstacles.splice(index, 1);
                    } else if (obstacle.x < stack.x && !scoredObstacles.has(obstacle)) {
                        score++;
                        document.getElementById('score').innerText = score;
                        const highScoreElement = document.getElementById('high-score');
                        if (parseInt(highScoreElement.innerText) < score) {
                            highScoreElement.innerText = score;
                        }
                        scoredObstacles.add(obstacle);
                    }
                });
            }

            let canJump = true; // Flag for debounce

            function flap() {
                if (canJump) {
                    stack.velocity = stack.lift; // Immediate jump response
                    canJump = false; // Disable jumping
                    setTimeout(() => {
                        canJump = true; // Re-enable jumping after 0.4 seconds
                    }, 300);
                }
            }

            function update() {
                stack.velocity += stack.gravity;
                stack.y += stack.velocity;
                if (stack.y + stack.height >= canvas.height) {
                    stack.y = canvas.height - stack.height;
                    stack.velocity = 0;
                }
                if (stack.y <= 0) {
                    stack.y = 0;
                    stack.velocity = 0;
                }
            }

            function checkCollision() {
                obstacles.forEach(obstacle => {
                    if (stack.x < obstacle.x + obstacle.width &&
                        stack.x + stack.width > obstacle.x &&
                        (stack.y < obstacle.height || stack.y + stack.height > obstacle.height + 150)) {
                        console.log('Hit a wall! Resetting scene.');
                        // Reset player position and velocity
                        stack.y = 150; // Reset to spawn position
                        stack.velocity = 0; // Reset velocity
                        // Reset obstacles and score
                        obstacles = []; // Clear obstacles
                        score = 0; // Reset score
                        document.getElementById('score').innerText = score;
                    }
                });
            }

            let frames = 0;
            console.log('Initializing game loop...');
            function gameLoop() {
                frames++;
                context.clearRect(0, 0, canvas.width, canvas.height);
                drawStack();
                drawObstacles();
                update();
                updateObstacles();
                checkCollision();
                requestAnimationFrame(gameLoop);
            }

            window.addEventListener('keydown', flap);
            document.addEventListener('touchstart', (e) => {
                if (e.touches.length === 1) {
                    flap();
                }
            });
            gameLoop();
        } catch (error) {
            console.error('An error occurred in the game script:', error);
        }
    </script>
    <script>
      setTimeout(() => {
        const instructions = document.getElementById('instructions');
        if (instructions) {
          instructions.classList.add('hidden');
        }
      }, 5000);
    </script>
</div>
