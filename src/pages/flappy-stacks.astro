---
// This is one page in a larger astro codebase. prefer using typescript that will compile without errors.
import Header from "../components/Header.astro";

// Define metadata for the page
const meta = {
  title: "Flappy Stacks",
  description: "A fun stacking game inspired by Flappy Bird",
};
---

<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
    <meta name="description" content={meta.description} />
    <title>{meta.title}</title>
    <style>
      html, body {
        margin: 0;
        padding: 0;
        overflow: hidden;
        height: 100%;
      }
      body {
        background: linear-gradient(to bottom, #87CEEB, #f0f8ff); /* Sky blue to light blue gradient */
      }
      #high-score {
        font-size: 20vw; /* Large size relative to viewport width */
        color: black; /* Black text color */
        pointer-events: none; /* Prevent interaction */
        z-index: 500; /* Positioned between background and game elements */
        font-size: 36px;
      }
      .instructions {
        position: absolute;
        bottom: 1vw;
        right: 0px;
        background-color: rgba(255, 255, 255, 1);
        padding: 20px;
        pointer-events: none;
        border-radius: 10px;
        text-align: center;
        font-size: 16px; /* Smaller size for better visibility */
        color: #333;
        z-index: 1000;
        transition: opacity 0.5s ease;
      }
      #score-counter {
        user-select: none; /* For modern browsers */
        -webkit-user-select: none; /* For Safari */
        -ms-user-select: none; /* For IE 10+ */
      }
      #canvas {
        background-image: url('/logo.png'); /* Add your desired background image */
        background-size: 2000px;
      animation: scrollBackground 20s linear infinite alternate;
        background-color: rgba(255,255,255,0.5);
        background-blend-mode: lighten;
      }

      @keyframes scrollBackground {
        from { background-position: 0 0; }
        to { background-position: -1000px -1000px; }
      }
      canvas {
        user-select: none; /* For modern browsers */
        -webkit-user-select: none; /* For Safari */
        -ms-user-select: none; /* For IE 10+ */
      }
      .hidden {
        opacity: 0;
        visibility: hidden;
      }
      .win-message {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background-color: rgba(255, 255, 255, 0.8);
        padding: 20px;
        border-radius: 10px;
        text-align: center;
        font-size: 24px;
        color: #333;
        z-index: 1000;
        display: none;
      }
    </style>
  </head>
  <body>
    <Header />
    <div id="game" class="max-w-3xl mx-auto overflow-hidden" style="position: relative;">
        
        <p id="instructions" class="instructions">Flap your way to glory by tapping<br>(or pressing the space bar)<br> Get a score of 10 for a BIG surprise!
          <br>Current best:
          <span id="high-score">0</span>
        </p>
        <div id="score-counter" style="visibility: hidden; position: absolute; bottom: 20px; left: 20px; color: white;">
          <small>Score</small>
          <h1 id="score" style="margin: 0;">0</h1>
        </div>
        <div id="win-message" class="win-message">
          You won! Tag us on IG to get 10 Variety Gifts tokens (redeemable for $10 in the Variety Gifts shop.)
        </div>
        <canvas id="canvas" class="aspect-ratio-16-9"></canvas>
        <script>
            try {
                //const canvas = document.createElement('canvas');
                const canvas = document.getElementById('canvas') as HTMLCanvasElement;
                const context = canvas.getContext('2d');
              // canvas.className = 'w-100 ';
              //document.getElementById('game').appendChild(canvas);
              canvas.width = 1280; 
              canvas.height = 720;

                let stack = { x: 50, y: 150, width: 50, height: 50, gravity: 0.6, lift: -15, velocity: 0 };
                let obstacles = [];
                let score = 0;
                let scoredObstacles = new Set();

                const popSound = new Audio('/flappy-stacks/pop.mp3');

                function playPopSound() {
                    popSound.currentTime = 0; // Start from the beginning
                    popSound.play();
                    setTimeout(() => {
                        popSound.pause();
                    }, 200); // Pause after 200ms
                }


                // Initialize high score from localStorage
                const storedHighScore = localStorage.getItem('highScore');
                const highScoreElement = document.getElementById('high-score');
                if (storedHighScore) {
                    highScoreElement.innerText = storedHighScore;
                }

                function updateHighScore() {
                    if (score > parseInt(highScoreElement.innerText)) {
                        highScoreElement.innerText = score.toString();
                        localStorage.setItem('highScore', score.toString());
                        //playChachingSound();
                      //drumrollSound.play(); // Resume drumroll if a new high score is achieved
                    }
                }

                function createObstaclePattern() {
                    const patternCanvas = document.createElement('canvas');
                    patternCanvas.width = 10;
                    patternCanvas.height = 10;
                    const patternContext = patternCanvas.getContext('2d');

                    patternContext.fillStyle = 'green';
                    patternContext.fillRect(0, 0, 10, 10);
                    patternContext.fillStyle = 'darkgreen';
                    patternContext.beginPath();
                    patternContext.arc(5, 5, 3, 0, Math.PI * 2);
                    patternContext.fill();

                    return context.createPattern(patternCanvas, 'repeat');
                }

                const obstaclePattern = createObstaclePattern();

                function drawObstacles() {
                    obstacles.forEach(obstacle => {
                        context.fillStyle = obstaclePattern;
                        context.fillRect(obstacle.x, 0, obstacle.width, obstacle.height);
                        context.fillRect(obstacle.x, obstacle.height + 200, obstacle.width, canvas.height - obstacle.height - 175);
                    });
                }

                function updateObstacles() {
                    if (frames % 75 === 0) {
                        obstacles.push({ x: 600, width: 50, height: Math.random() * (canvas.height - 200) / 2 });
                    }
                    obstacles.forEach((obstacle, index) => {
                        obstacle.x -= 5;
                        if (obstacle.x + obstacle.width < 0) {
                            obstacles.splice(index, 1);
                        } else if (obstacle.x < stack.x && !scoredObstacles.has(obstacle)) {
                            score++;
                            playPopSound();
                            document.getElementById('score').innerText = score.toString();
                            updateHighScore();
                            scoredObstacles.add(obstacle);
                        }
                    });
                }

                let canJump = true; // Flag for debounce

                function flap() {
                    if (canJump) {
                        playFlapSound(); // Play sound on flap
                        stack.velocity = stack.lift; // Immediate jump response
                        canJump = false; // Disable jumping
                        setTimeout(() => {
                            canJump = true; // Re-enable jumping after 0.4 seconds
                        }, 150);
                    }
                }

                const flapSound = new Audio('/flappy-stacks/flap.mp3');

                function playFlapSound() {
                    flapSound.currentTime = 0; // Reset to start
                    flapSound.play();
                    //setTimeout(() => flapSound.pause(), 200); // Play only first 200ms
                }

                function update() {
                    stack.velocity += stack.gravity;
                    stack.y += stack.velocity;
                    if (stack.y + stack.height >= canvas.height) {
                        stack.y = canvas.height - stack.height;
                        stack.velocity = 0;
                    }
                    if (stack.y <= 0) {
                        stack.y = 0;
                        stack.velocity = 0;
                    }
                }

                function checkCollision() {
                    obstacles.forEach(obstacle => {
                        if (stack.x < obstacle.x + obstacle.width &&
                            stack.x + stack.width > obstacle.x &&
                            (stack.y < obstacle.height || stack.y + stack.height > obstacle.height + 200)) {
                            console.log('Hit a wall! Resetting scene.');
                            // Reset player position and velocity
                            stack.y = 150; // Reset to spawn position
                            stack.velocity = 0; // Reset velocity
                            // Reset obstacles and score
                            obstacles = []; // Clear obstacles
                            score = 0; // Reset score
                            document.getElementById('score').innerText = score.toString();
                        }
                    });
                }

                function checkWinCondition() {
                    if (score >= 10) {
                        const winMessage = document.getElementById('win-message');
                        if (winMessage) {
                            winMessage.style.display = 'block';
                        }
                    }
                }

                let frames = 0;
                let currentFrame = 0;
                const frameWidth = 1024 / 4; // Assuming each frame is 100px wide
                const frameHeight = 1024 / 5; // Assuming each frame is 100px tall
                const totalFrames = 20; // 4 columns * 5 rows
                const spriteSheet = new Image();
                spriteSheet.src = '/flappy-stacks/money_sprite_sheet.png';

                let lastFrameTime = 0;
                const fixedTimeStep = 1000 / 60; // 60 updates per second
                let accumulatedTime = 0;

                console.log('Initializing game loop...');
                function gameLoop(currentTime) {
                    // Calculate time since last frame
                    const deltaTime = currentTime - lastFrameTime;
                    lastFrameTime = currentTime;
                    accumulatedTime += deltaTime;

                    // Update game logic with fixed time step
                    while (accumulatedTime >= fixedTimeStep) {
                        update();
                        updateObstacles();
                        checkCollision();
                        checkWinCondition();
                        accumulatedTime -= fixedTimeStep;
                    }

                    // Render the frame
                    context.clearRect(0, 0, canvas.width, canvas.height);
                    const row = Math.floor(currentFrame / 4);
                    const col = currentFrame % 4;
                    const offsetX = col * frameWidth;
                    const offsetY = row * frameHeight;
                    context.drawImage(spriteSheet, offsetX, offsetY, frameWidth, frameHeight, stack.x, stack.y, stack.width, stack.height);
                    if (frames % 10 === 0) {
                        currentFrame = (currentFrame + 1) % totalFrames;
                    }
                    drawObstacles();

                    frames++;
                    requestAnimationFrame((currentTime) => gameLoop(currentTime));
                }

                const soundtrack = new Audio('/flappy-stacks/soundtrack.mp3');
                soundtrack.addEventListener('canplaythrough', () => {
                    soundtrack.play(); // Play once loaded
                }, { once: true });
                soundtrack.load(); // Defer loading

                window.addEventListener('keydown', (e) => {
                    e.preventDefault();
                    flap();
                  });
                document.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    if (e.touches.length === 1) {
                        flap();
                    }
                });
                requestAnimationFrame((currentTime) => gameLoop(currentTime));
            } catch (error) {
                console.error('An error occurred in the game script:', error);
            }
        </script>
        <script>
          setTimeout(() => {
            const instructions = document.getElementById('instructions');
            if (instructions) {
              instructions.style.opacity = "1.0"; // Ensure instructions remain visible
            }
          }, 0); // Remove delay to prevent hiding
        </script>
    </div>
  </body>
</html>
